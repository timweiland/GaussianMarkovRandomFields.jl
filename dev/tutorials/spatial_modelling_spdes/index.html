<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Spatial Modelling with SPDEs · GaussianMarkovRandomFields.jl</title><meta name="title" content="Spatial Modelling with SPDEs · GaussianMarkovRandomFields.jl"/><meta property="og:title" content="Spatial Modelling with SPDEs · GaussianMarkovRandomFields.jl"/><meta property="twitter:title" content="Spatial Modelling with SPDEs · GaussianMarkovRandomFields.jl"/><meta name="description" content="Documentation for GaussianMarkovRandomFields.jl."/><meta property="og:description" content="Documentation for GaussianMarkovRandomFields.jl."/><meta property="twitter:description" content="Documentation for GaussianMarkovRandomFields.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GaussianMarkovRandomFields.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GaussianMarkovRandomFields.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../autoregressive_models/">Building autoregressive models</a></li><li class="is-active"><a class="tocitem" href>Spatial Modelling with SPDEs</a><ul class="internal"><li><a class="tocitem" href="#Data-preprocessing"><span>Data preprocessing</span></a></li><li><a class="tocitem" href="#Spatial-Modelling"><span>Spatial Modelling</span></a></li><li><a class="tocitem" href="#Final-note"><span>Final note</span></a></li></ul></li><li><a class="tocitem" href="../spatiotemporal_modelling/">Spatiotemporal Modelling with SPDEs</a></li><li><a class="tocitem" href="../autodiff_mcmc/">Automatic Differentiation and MCMC</a></li><li><a class="tocitem" href="../boundary_conditions/">Boundary Conditions for SPDEs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/">Overview</a></li><li><a class="tocitem" href="../../reference/gmrfs/">GMRFs</a></li><li><a class="tocitem" href="../../reference/spdes/">SPDEs</a></li><li><a class="tocitem" href="../../reference/discretizations/">Discretizations</a></li><li><a class="tocitem" href="../../reference/meshes/">Meshes</a></li><li><a class="tocitem" href="../../reference/plotting/">Plotting</a></li><li><a class="tocitem" href="../../reference/solvers/">Solvers</a></li><li><a class="tocitem" href="../../reference/autoregressive/">Autoregressive Models</a></li><li><a class="tocitem" href="../../reference/linear_maps/">Linear maps</a></li><li><a class="tocitem" href="../../reference/gn_optim/">Gauss-Newton optimization</a></li><li><a class="tocitem" href="../../reference/preconditioners/">Preconditioners</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../dev-docs/">Overview</a></li><li><a class="tocitem" href="../../dev-docs/solvers/">Solvers</a></li><li><a class="tocitem" href="../../dev-docs/spdes/">SPDEs</a></li><li><a class="tocitem" href="../../dev-docs/discretizations/">Discretizations</a></li><li><a class="tocitem" href="../../dev-docs/utils/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Spatial Modelling with SPDEs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Spatial Modelling with SPDEs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/timweiland/GaussianMarkovRandomFields.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/main/docs/src/literate-tutorials/spatial_modelling_spdes.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Spatial-Modelling-with-SPDEs"><a class="docs-heading-anchor" href="#Spatial-Modelling-with-SPDEs">Spatial Modelling with SPDEs</a><a id="Spatial-Modelling-with-SPDEs-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-Modelling-with-SPDEs" title="Permalink"></a></h1><h2 id="Data-preprocessing"><a class="docs-heading-anchor" href="#Data-preprocessing">Data preprocessing</a><a id="Data-preprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Data-preprocessing" title="Permalink"></a></h2><p>In the following, we are going to work with the <code>meuse</code> dataset. This dataset contains measurements of zinc concentrations in the soil near the Meuse river.</p><p>We begin by downloading the dataset.</p><pre><code class="language-julia hljs">meuse_path = joinpath(@__DIR__, &quot;meuse.csv&quot;)
meuse_URL = &quot;https://gist.githubusercontent.com/essicolo/91a2666f7c5972a91bca763daecdc5ff/raw/056bda04114d55b793469b2ab0097ec01a6d66c6/meuse.csv&quot;
download(meuse_URL, meuse_path)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;/home/runner/work/GaussianMarkovRandomFields.jl/GaussianMarkovRandomFields.jl/docs/build/tutorials/meuse.csv&quot;</code></pre><p>We load the CSV file into a DataFrame and inspect the first few rows.</p><pre><code class="language-julia hljs">using CSV, DataFrames
df = DataFrame(CSV.File(meuse_path))
df[1:5, [:x, :y, :zinc]]</code></pre><div><div style = "float: left;"><span>5×3 DataFrame</span></div><div style = "clear: both;"></div></div><div class = "data-frame" style = "overflow-x: scroll;"><table class = "data-frame" style = "margin-bottom: 6px;"><thead><tr class = "header"><th class = "rowNumber" style = "font-weight: bold; text-align: right;">Row</th><th style = "text-align: left;">x</th><th style = "text-align: left;">y</th><th style = "text-align: left;">zinc</th></tr><tr class = "subheader headerLastRow"><th class = "rowNumber" style = "font-weight: bold; text-align: right;"></th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Int64" style = "text-align: left;">Int64</th><th title = "Int64" style = "text-align: left;">Int64</th></tr></thead><tbody><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">1</td><td style = "text-align: right;">181072</td><td style = "text-align: right;">333611</td><td style = "text-align: right;">1022</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">2</td><td style = "text-align: right;">181025</td><td style = "text-align: right;">333558</td><td style = "text-align: right;">1141</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">3</td><td style = "text-align: right;">181165</td><td style = "text-align: right;">333537</td><td style = "text-align: right;">640</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">4</td><td style = "text-align: right;">181298</td><td style = "text-align: right;">333484</td><td style = "text-align: right;">257</td></tr><tr><td class = "rowNumber" style = "font-weight: bold; text-align: right;">5</td><td style = "text-align: right;">181307</td><td style = "text-align: right;">333330</td><td style = "text-align: right;">269</td></tr></tbody></table></div><p>Let us visualize the data. We plot the zinc concentrations as a function of the x and y coordinates.</p><pre><code class="language-julia hljs">using Plots
x = convert(Vector{Float64}, df[:, :x])
y = convert(Vector{Float64}, df[:, :y])
zinc = df[:, :zinc]
scatter(x, y, zcolor = zinc)</code></pre><img src="74299212.svg" alt="Example block output"/><p>Finally, in classic machine learning fashion, we split the data into a training and a test set. We use about 85% of the data for training and the remaining 15% for testing.</p><pre><code class="language-julia hljs">using Random
train_idcs = randsubseq(1:size(df, 1), 0.85)
test_idcs = [i for i = 1:size(df, 1) if isempty(searchsorted(train_idcs, i))]
X = [x y]
X_train = X[train_idcs, :]
X_test = X[test_idcs, :]
y_train = zinc[train_idcs]
y_test = zinc[test_idcs]
size(X_train, 1), size(X_test, 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(133, 22)</code></pre><h2 id="Spatial-Modelling"><a class="docs-heading-anchor" href="#Spatial-Modelling">Spatial Modelling</a><a id="Spatial-Modelling-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-Modelling" title="Permalink"></a></h2><p>Matern Gaussian processes (GPs) are a powerful model class commonly used in geostatistics for such data. Unfortunately, without using any further tricks, GPs have a cubic runtime complexity. As the size of the dataset grows, this quickly becomes prohibitively expensive. In the tutorial on Autoregressive models, we learned that GMRFs enable highly efficient Gaussian inference through sparse precision matrices. Can we combine the modelling power of GPs with the efficiency of GMRFs?</p><p>Yes, we can: [<a href="../../bibliography/#Lindgren2011">1</a>] told us how. It turns out that Matern processes may equivalently be interpreted as solutions of certain stochastic partial differential equations (SPDEs). If we discretize this SPDE appropriately – for example using the finite element method (FEM) – we get a discrete GMRF approximation of a Matern process. The approximation quality improves as the resolution of the FEM mesh increases. If this all sounds overly complicated to you, fear not! GaussianMarkovRandomFields.jl takes care of the technical details for you, so you can focus on the modelling.</p><p>We start by generating a FEM mesh for our data. Internally, GaussianMarkovRandomFields.jl computes a convex hull around the scattered data and then extends it slightly to counteract effects from the boundary condition of the SPDE.</p><p><img src="../meuse_msh_fig.png" alt="This image depicts the mesh generated for the scattered data."/></p><p>The final output is a Ferrite.jl grid. We can also save the generated mesh, e.g. to visualize it via Gmsh.</p><pre><code class="language-julia hljs">using GaussianMarkovRandomFields
points = zip(x, y)
grid = generate_mesh(points, 600.0, 100.0, save_path = &quot;meuse.msh&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Grid{2, Triangle, Float64} with 2143 Triangle cells and 1119 nodes</code></pre><p>We can now create a FEM discretization, which consists of the grid, a choice of basis functions, and a quadrature rule.</p><pre><code class="language-julia hljs">using Ferrite
ip = Lagrange{RefTriangle,1}()
qr = QuadratureRule{RefTriangle}(2)
disc = FEMDiscretization(grid, ip, qr)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FEMDiscretization
  grid: Grid{2, Triangle, Float64} with 2143 Triangle cells and 1119 nodes
  interpolation: Lagrange{RefTriangle, 1}()
  quadrature_rule: QuadratureRule{RefTriangle, Vector{Float64}, Vector{Vec{2, Float64}}}
  # constraints: 0
</code></pre><p>We now create a Matern SPDE and discretize it. While we could specify the Matern SPDE in terms of its direct parameters κ and ν, we here choose to specify it through the more easily interpretable parameters <code>range</code> and <code>smoothness</code>.</p><pre><code class="language-julia hljs">spde = MaternSPDE{2}(range = 400.0, smoothness = 1)
u_matern = discretize(spde, disc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GMRF{Float64, LinearMapWithSqrt{Float64, LinearMaps.WrappedMap{Float64, LinearAlgebra.Symmetric{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}}, LinearMaps.WrappedMap{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}}, CholeskySolver{:default, TakahashiStrategy, Float64, LinearMapWithSqrt{Float64, LinearMaps.WrappedMap{Float64, LinearAlgebra.Symmetric{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}}, LinearMaps.WrappedMap{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}}, SparseArrays.CHOLMOD.Factor{Float64, Int64}}}(
mean: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
precision: 1119×1119 LinearMapWithSqrt{Float64}
solver: CholeskySolver{:default, TakahashiStrategy, Float64, LinearMapWithSqrt{Float64, LinearMaps.WrappedMap{Float64, LinearAlgebra.Symmetric{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}}, LinearMaps.WrappedMap{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}}, SparseArrays.CHOLMOD.Factor{Float64, Int64}}([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 1119×1119 LinearMapWithSqrt{Float64}, SparseArrays.CHOLMOD.Factor{Float64, Int64}
type:    LLt
method:  supernodal
maxnnz:  0
nnz:     97872
success: true
, TakahashiStrategy(), nothing, nothing, nothing)
)
</code></pre><p>We can then condition the resulting Matern GMRF on the training data, where we assume an inverse noise variance of 10 (i.e. a variance of 0.1).</p><pre><code class="language-julia hljs">Λ_obs = 10.0
A_train =
    evaluation_matrix(disc, [Tensors.Vec(X_train[i, :]...) for i = 1:size(X_train, 1)])
A_test = evaluation_matrix(disc, [Tensors.Vec(X_test[i, :]...) for i = 1:size(X_test, 1)])
u_cond = condition_on_observations(u_matern, A_train, Λ_obs, y_train)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearConditionalGMRF of size 1119 and solver LinearConditionalCholeskySolver{:default, TakahashiStrategy, Float64, LinearMaps.LinearCombination{Float64, Tuple{LinearMapWithSqrt{Float64, LinearMaps.WrappedMap{Float64, LinearAlgebra.Symmetric{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}}, LinearMaps.WrappedMap{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}, SparseArrays.SparseMatrixCSC{Float64, Int64}}, OuterProductMap{Float64}}}, SparseArrays.CHOLMOD.Factor{Float64, Int64}, LinearMaps.WrappedMap{Float64, SparseArrays.SparseMatrixCSC{Float64, Int64}}, LinearMaps.UniformScalingMap{Float64}}</code></pre><p>We can evaluate the RMSE of the posterior mean on the test data:</p><pre><code class="language-julia hljs">rmse = (a, b) -&gt; sqrt(mean((a .- b) .^ 2))
rmse(A_train * mean(u_cond), y_train), rmse(A_test * mean(u_cond), y_test)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(51.60352560323246, 191.80093500982446)</code></pre><p>We can also visualize the posterior mean and standard deviation. To this end, we write the corresponding vectors to a VTK file together with the grid data, which can then be visualized in e.g. Paraview.</p><pre><code class="language-julia hljs">VTKGridFile(&quot;meuse_mean&quot;, disc.dof_handler) do vtk
    write_solution(vtk, disc.dof_handler, mean(u_cond))
end
using Distributions
VTKGridFile(&quot;meuse_std&quot;, disc.dof_handler) do vtk
    write_solution(vtk, disc.dof_handler, std(u_cond))
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">VTKGridFile for the closed file &quot;meuse_std.vtu&quot;.</code></pre><p>In the end, our posterior mean looks like this: <img src="../meuse_mean.png" alt="Mean"/></p><p>And the posterior standard deviation looks like this: <img src="../meuse_std.png" alt="Std"/></p><h2 id="Final-note"><a class="docs-heading-anchor" href="#Final-note">Final note</a><a id="Final-note-1"></a><a class="docs-heading-anchor-permalink" href="#Final-note" title="Permalink"></a></h2><p>We have seen how to combine the modelling power of GPs with the efficiency of GMRFs. This is a powerful combination that allows us to model spatial data efficiently and accurately. Note that these models are still sensitive to the choice of hyperparameters, i.e. the range and smoothness of the Matern process. So it&#39;s quite likely that you may find better hyperparameters than the ones used in this tutorial.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../autoregressive_models/">« Building autoregressive models</a><a class="docs-footer-nextpage" href="../spatiotemporal_modelling/">Spatiotemporal Modelling with SPDEs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.12.0 on <span class="colophon-date" title="Monday 16 June 2025 16:02">Monday 16 June 2025</span>. Using Julia version 1.10.9.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
