<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Boundary Conditions for SPDEs · GaussianMarkovRandomFields.jl</title><meta name="title" content="Boundary Conditions for SPDEs · GaussianMarkovRandomFields.jl"/><meta property="og:title" content="Boundary Conditions for SPDEs · GaussianMarkovRandomFields.jl"/><meta property="twitter:title" content="Boundary Conditions for SPDEs · GaussianMarkovRandomFields.jl"/><meta name="description" content="Documentation for GaussianMarkovRandomFields.jl."/><meta property="og:description" content="Documentation for GaussianMarkovRandomFields.jl."/><meta property="twitter:description" content="Documentation for GaussianMarkovRandomFields.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="GaussianMarkovRandomFields.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">GaussianMarkovRandomFields.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../autoregressive_models/">Building autoregressive models</a></li><li><a class="tocitem" href="../spatial_modelling_spdes/">Spatial Modelling with SPDEs</a></li><li><a class="tocitem" href="../spatiotemporal_modelling/">Spatiotemporal Modelling with SPDEs</a></li><li class="is-active"><a class="tocitem" href>Boundary Conditions for SPDEs</a><ul class="internal"><li><a class="tocitem" href="#Spatial-example:-Matern-SPDE"><span>Spatial example: Matern SPDE</span></a></li><li><a class="tocitem" href="#Spatiotemporal-example:-Advection-Diffusion-SPDE"><span>Spatiotemporal example: Advection-Diffusion SPDE</span></a></li><li><a class="tocitem" href="#Conclusion"><span>Conclusion</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/">Overview</a></li><li><a class="tocitem" href="../../reference/gmrfs/">GMRFs</a></li><li><a class="tocitem" href="../../reference/spdes/">SPDEs</a></li><li><a class="tocitem" href="../../reference/discretizations/">Discretizations</a></li><li><a class="tocitem" href="../../reference/meshes/">Meshes</a></li><li><a class="tocitem" href="../../reference/plotting/">Plotting</a></li><li><a class="tocitem" href="../../reference/solvers/">Solvers</a></li><li><a class="tocitem" href="../../reference/autoregressive/">Autoregressive Models</a></li><li><a class="tocitem" href="../../reference/linear_maps/">Linear maps</a></li><li><a class="tocitem" href="../../reference/gn_optim/">Gauss-Newton optimization</a></li><li><a class="tocitem" href="../../reference/preconditioners/">Preconditioners</a></li></ul></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Developer Documentation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../dev-docs/">Overview</a></li><li><a class="tocitem" href="../../dev-docs/solvers/">Solvers</a></li><li><a class="tocitem" href="../../dev-docs/spdes/">SPDEs</a></li><li><a class="tocitem" href="../../dev-docs/discretizations/">Discretizations</a></li><li><a class="tocitem" href="../../dev-docs/utils/">Utilities</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Boundary Conditions for SPDEs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Boundary Conditions for SPDEs</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/timweiland/GaussianMarkovRandomFields.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/main/docs/src/literate-tutorials/boundary_conditions.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Boundary-Conditions-for-SPDEs"><a class="docs-heading-anchor" href="#Boundary-Conditions-for-SPDEs">Boundary Conditions for SPDEs</a><a id="Boundary-Conditions-for-SPDEs-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-Conditions-for-SPDEs" title="Permalink"></a></h1><p>In previous tutorials, we saw that we can approximate stochastic processes with GMRFs by discretizing stochastic partial differential equations (SPDEs). Such discretizations always involve boundary conditions, which specify the behavior of the process at the boundary of the domain. In the context of the finite element method, the simplest boundary condition is a homogeneous von Neumann boundary condition, which specifies that the derivative of the process normal to the boundary is zero. This approach is also used in the seminal work by Lindgren et al. [<a href="../../bibliography/#Lindgren2011">1</a>].</p><p>Yet, in practice, this behavior is often not desirable. To circumvent boundary effects, people often artificially inflate the domain by adding a buffer zone around the data.</p><p>But what if we know the behavior of the process at the boundary, and it&#39;s not &quot;the normal derivative is zero&quot;? Fortunately, GaussianMarkovRandomFields.jl interfaces rather smoothly with Ferrite.jl, which we can use to specify more complex boundary conditions. Let&#39;s see how this works.</p><h2 id="Spatial-example:-Matern-SPDE"><a class="docs-heading-anchor" href="#Spatial-example:-Matern-SPDE">Spatial example: Matern SPDE</a><a id="Spatial-example:-Matern-SPDE-1"></a><a class="docs-heading-anchor-permalink" href="#Spatial-example:-Matern-SPDE" title="Permalink"></a></h2><p>We start by specifying a mesh over the interval [-1, 1].</p><pre><code class="language-julia hljs">using GaussianMarkovRandomFields, Ferrite
grid = generate_grid(Line, (50,))
interpolation = Lagrange{RefLine,1}()
quadrature_rule = QuadratureRule{RefLine}(2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">QuadratureRule{RefLine, Vector{Float64}, Vector{Vec{1, Float64}}}([0.9999999999999998, 0.9999999999999998], Vec{1, Float64}[[-0.5773502691896257], [0.5773502691896257]])</code></pre><h3 id="Dirichlet-boundary"><a class="docs-heading-anchor" href="#Dirichlet-boundary">Dirichlet boundary</a><a id="Dirichlet-boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Dirichlet-boundary" title="Permalink"></a></h3><p>Let us now use Ferrite to define a homogeneous Dirichlet boundary condition, which specifies that the process is zero at the boundary.</p><pre><code class="language-julia hljs">function get_dirichlet_constraint(grid::Ferrite.Grid{1})
    boundary = getfacetset(grid, &quot;left&quot;) ∪ getfacetset(grid, &quot;right&quot;)

    return Dirichlet(:u, boundary, x -&gt; (x[1] ≈ -1.0) ? 0.0 : (x[1] ≈ 1.0) ? 0.0 : 0.0)
end

dbc = get_dirichlet_constraint(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dirichlet(Main.var&quot;#1#2&quot;(), OrderedCollections.OrderedSet{FacetIndex}(FacetIndex[FacetIndex((1, 1)), FacetIndex((50, 2))]), :u, Int64[], Int64[], Int64[])</code></pre><p>GaussianMarkovRandomFields.jl supports such boundary conditions in a &quot;soft&quot; way. This means that we enforce the boundary conditions up to noise of a certain, user-specified magnitude. This ensures that the resulting GMRF has full rank. If you don&#39;t care much for probabilistic boundary conditions, you can just set the noise to a sufficiently small value.</p><pre><code class="language-julia hljs">bcs = [(dbc, 1e-4)] # 1e-4 is the noise in terms of the standard deviation</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">1-element Vector{Tuple{Dirichlet, Float64}}:
 (Dirichlet(Main.var&quot;#1#2&quot;(), OrderedCollections.OrderedSet{FacetIndex}(FacetIndex[FacetIndex((1, 1)), FacetIndex((50, 2))]), :u, Int64[], Int64[], Int64[]), 0.0001)</code></pre><p>We can now create a FEM discretization with the specified boundary conditions.</p><pre><code class="language-julia hljs">disc = FEMDiscretization(grid, interpolation, quadrature_rule, [(:u, nothing)], bcs)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">FEMDiscretization
  grid: Grid{1, Line, Float64} with 50 Line cells and 51 nodes
  interpolation: Lagrange{RefLine, 1}()
  quadrature_rule: QuadratureRule{RefLine, Vector{Float64}, Vector{Vec{1, Float64}}}
  # constraints: 2
</code></pre><p>Let&#39;s now define some Matern SPDE and discretize it.</p><pre><code class="language-julia hljs">matern_spde = MaternSPDE{1}(range = 0.5, smoothness = 1, σ² = 0.3)
x = discretize(matern_spde, disc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GMRF{Float64}(
mean: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
precision: 51×51 LinearMapWithSqrt{Float64}
solver_ref: Base.RefValue{AbstractSolver}(CholeskySolver{TakahashiStrategy}([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 51×51 LinearMapWithSqrt{Float64}, SparseArrays.CHOLMOD.Factor{Float64, Int64}
type:    LLt
method:  simplicial
maxnnz:  150
nnz:     150
success: true
, TakahashiStrategy(), nothing, nothing))
)
</code></pre><p>Verify for yourself that the boundary value is zero for all samples, and that the variance vanishes at the boundary:</p><pre><code class="language-julia hljs">using CairoMakie
CairoMakie.activate!()
plot(x, disc)</code></pre><img src="38ef20aa.png" alt="Example block output"/><h3 id="Periodic-boundary"><a class="docs-heading-anchor" href="#Periodic-boundary">Periodic boundary</a><a id="Periodic-boundary-1"></a><a class="docs-heading-anchor-permalink" href="#Periodic-boundary" title="Permalink"></a></h3><p>We can also define a periodic boundary condition in terms of an affine constraint:</p><pre><code class="language-julia hljs">function get_periodic_constraint(grid::Ferrite.Grid{1})
    cellidx_left, dofidx_left = collect(grid.facetsets[&quot;left&quot;])[1]
    cellidx_right, dofidx_right = collect(grid.facetsets[&quot;right&quot;])[1]

    temp_dh = DofHandler(grid)
    add!(temp_dh, :u, Lagrange{RefLine,1}())
    close!(temp_dh)
    cc = CellCache(temp_dh)
    get_dof(cell_idx, dof_idx) = (reinit!(cc, cell_idx); celldofs(cc)[dof_idx])
    dof_left = get_dof(cellidx_left, dofidx_left)
    dof_right = get_dof(cellidx_right, dofidx_right)

    return AffineConstraint(dof_left, [dof_right =&gt; 1.0], 0.0)
end

pbc = get_periodic_constraint(grid)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">AffineConstraint{Float64}(1, [51 =&gt; 1.0], 0.0)</code></pre><p>The rest of the procedure is analogous to the Dirichlet case:</p><pre><code class="language-julia hljs">bcs = [(pbc, 1e-4)]
disc_periodic =
    FEMDiscretization(grid, interpolation, quadrature_rule, [(:u, nothing)], bcs)
x_periodic = discretize(matern_spde, disc_periodic)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GMRF{Float64}(
mean: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
precision: 51×51 LinearMapWithSqrt{Float64}
solver_ref: Base.RefValue{AbstractSolver}(CholeskySolver{TakahashiStrategy}([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 51×51 LinearMapWithSqrt{Float64}, SparseArrays.CHOLMOD.Factor{Float64, Int64}
type:    LLt
method:  simplicial
maxnnz:  198
nnz:     198
success: true
, TakahashiStrategy(), nothing, nothing))
)
</code></pre><p>Verify for yourself that the values at the left and right boundary match for all samples:</p><pre><code class="language-julia hljs">plot(x_periodic, disc)</code></pre><img src="9bf4b6f1.png" alt="Example block output"/><h2 id="Spatiotemporal-example:-Advection-Diffusion-SPDE"><a class="docs-heading-anchor" href="#Spatiotemporal-example:-Advection-Diffusion-SPDE">Spatiotemporal example: Advection-Diffusion SPDE</a><a id="Spatiotemporal-example:-Advection-Diffusion-SPDE-1"></a><a class="docs-heading-anchor-permalink" href="#Spatiotemporal-example:-Advection-Diffusion-SPDE" title="Permalink"></a></h2><p>This works just as well in the spatiotemporal case. Let&#39;s reuse our previous discretization for a 1D advection-diffusion SPDE:</p><pre><code class="language-julia hljs">using LinearAlgebra, SparseArrays
spde = AdvectionDiffusionSPDE{1}(
    γ = [-0.6],
    H = 0.1 * sparse(I, (1, 1)),
    τ = 0.1,
    α = 2 // 1,
    spatial_spde = matern_spde,
    initial_spde = matern_spde,
)
ts = 0:0.05:1
N_t = length(ts)
x_adv_diff_dirichlet = discretize(spde, disc, ts)
x_adv_diff_periodic = discretize(spde, disc_periodic, ts)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ImplicitEulerConstantMeshSTGMRF{1, Float64}(
mean: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
precision: 1071×1071 LinearMapWithSqrt{Float64}
discretization: FEMDiscretization
  grid: Grid{1, Line, Float64} with 50 Line cells and 51 nodes
  interpolation: Lagrange{RefLine, 1}()
  quadrature_rule: QuadratureRule{RefLine, Vector{Float64}, Vector{Vec{1, Float64}}}
  # constraints: 1

ssm: ImplicitEulerSSM(GMRF{Float64}(
mean: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
precision: 51×51 LinearMapWithSqrt{Float64}
solver_ref: Base.RefValue{AbstractSolver}(CholeskySolver{TakahashiStrategy}([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 51×51 LinearMapWithSqrt{Float64}, SparseArrays.CHOLMOD.Factor{Float64, Int64}
type:    LLt
method:  simplicial
maxnnz:  198
nnz:     198
success: true
, TakahashiStrategy(), nothing, nothing))
)
, GaussianMarkovRandomFields.var&quot;#106#111&quot;{AdvectionDiffusionSPDE{1}}(AdvectionDiffusionSPDE{1}(1.0, 2//1, sparse([1], [1], [0.1], 1, 1), [-0.6], 1.0, 0.1, MaternSPDE{1}(6.928203230275509, 3//2, 0.3, LinearAlgebra.UniformScaling{Bool}(true)), MaternSPDE{1}(6.928203230275509, 3//2, 0.3, LinearAlgebra.UniformScaling{Bool}(true))), Core.Box(sparse([1, 2, 3, 4, 50, 51, 2, 3, 4, 5  …  2, 48, 49, 50, 51, 2, 3, 49, 50, 51], [1, 2, 2, 2, 2, 2, 3, 3, 3, 3  …  50, 50, 50, 50, 50, 51, 51, 51, 51, 51], [24.426989619377157, 37.90160000000003, -25.500000000000053, 6.250000000000005, 6.249999999999989, -24.89999999999997, -24.900000000000052, 37.90160000000003, -25.49999999999997, 6.249999999999989  …  6.249999999999989, 6.250000000000005, -24.900000000000052, 37.90160000000003, -25.49999999999997, -25.49999999999997, 6.250000000000005, 6.250000000000005, -24.89999999999997, 37.90159999999993], 51, 51)), Core.Box(sparse([1, 2, 1, 2, 3, 51, 2, 3, 4, 3  …  49, 48, 49, 50, 49, 50, 51, 2, 50, 51], [1, 1, 2, 2, 2, 2, 3, 3, 3, 4  …  48, 49, 49, 49, 50, 50, 50, 51, 51, 51], [0.03921568627450983, 0.0, 0.0, 0.03999999999999998, 0.0, 0.0, 0.0, 0.03999999999999998, 0.0, 0.0  …  0.0, 0.0, 0.03999999999999998, 0.0, 0.0, 0.03999999999999998, 0.0, 0.0, 0.0, 0.04000000000000003], 51, 51))), GaussianMarkovRandomFields.var&quot;#109#114&quot;(Core.Box(sparse([1, 2, 1, 2, 3, 51, 2, 3, 4, 3  …  49, 48, 49, 50, 49, 50, 51, 2, 50, 51], [1, 1, 2, 2, 2, 2, 3, 3, 3, 4  …  48, 49, 49, 49, 50, 50, 50, 51, 51, 51], [0.03921568627450983, 0.0, 0.0, 0.03999999999999998, 0.0, 0.0, 0.0, 0.03999999999999998, 0.0, 0.0  …  0.0, 0.0, 0.03999999999999998, 0.0, 0.0, 0.03999999999999998, 0.0, 0.0, 0.0, 0.04000000000000003], 51, 51))), GaussianMarkovRandomFields.var&quot;#110#115&quot;{SparseArrays.SparseMatrixCSC{Float64, Int64}}(sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  42, 43, 44, 45, 46, 47, 48, 49, 50, 51], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  42, 43, 44, 45, 46, 47, 48, 49, 50, 51], [25.499999999999982, 25.000000000000014, 25.000000000000014, 24.999999999999982, 25.000000000000014, 25.000000000000014, 24.999999999999982, 25.000000000000014, 25.000000000000014, 24.999999999999982  …  24.999999999999982, 25.000000000000014, 25.000000000000014, 24.999999999999982, 25.000000000000014, 25.000000000000014, 24.999999999999982, 25.000000000000014, 25.000000000000014, 24.999999999999982], 51, 51)), GaussianMarkovRandomFields.var&quot;#107#112&quot;{SparseArrays.SparseMatrixCSC{Float64, Int64}}(sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  42, 43, 44, 45, 46, 47, 48, 49, 50, 51], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  42, 43, 44, 45, 46, 47, 48, 49, 50, 51], [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1  …  0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1], 51, 51)), GaussianMarkovRandomFields.var&quot;#108#113&quot;{SparseArrays.SparseMatrixCSC{Float64, Int64}}(sparse([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  42, 43, 44, 45, 46, 47, 48, 49, 50, 51], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  42, 43, 44, 45, 46, 47, 48, 49, 50, 51], [10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0  …  10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0, 10.0], 51, 51)), GMRF{Float64}(
mean: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
precision: 51×51 LinearMapWithSqrt{Float64}
solver_ref: Base.RefValue{AbstractSolver}(CholeskySolver{TakahashiStrategy}([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 51×51 LinearMapWithSqrt{Float64}, SparseArrays.CHOLMOD.Factor{Float64, Int64}
type:    LLt
method:  simplicial
maxnnz:  198
nnz:     198
success: true
, TakahashiStrategy(), nothing, nothing))
)
, 0.0:0.05:1.0, ConstraintHandler{DofHandler{1, Grid{1, Line, Float64}}, Float64}(Dirichlet[], [1], [2, 3, 4, 5, 6, 7, 8, 9, 10, 11  …  42, 43, 44, 45, 46, 47, 48, 49, 50, 51], [0.0], Union{Nothing, Float64}[0.0], Union{Nothing, Vector{Pair{Int64, Float64}}}[[51 =&gt; 1.0]], Dict(1 =&gt; 1), Ferrite.BCValues{Float64}[], DofHandler{1, Grid{1, Line, Float64}}(SubDofHandler{DofHandler{1, Grid{1, Line, Float64}}}[SubDofHandler{DofHandler{1, Grid{1, Line, Float64}}}(DofHandler{1, Grid{1, Line, Float64}}(#= circular reference @-3 =#), OrderedCollections.OrderedSet{Int64}([1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  41, 42, 43, 44, 45, 46, 47, 48, 49, 50]), [:u], Interpolation[Lagrange{RefLine, 1}()], Int64[], 2)], [:u], [1, 2, 2, 3, 3, 4, 4, 5, 5, 6  …  46, 47, 47, 48, 48, 49, 49, 50, 50, 51], [1, 3, 5, 7, 9, 11, 13, 15, 17, 19  …  81, 83, 85, 87, 89, 91, 93, 95, 97, 99], [1, 1, 1, 1, 1, 1, 1, 1, 1, 1  …  1, 1, 1, 1, 1, 1, 1, 1, 1, 1], true, Grid{1, Line, Float64}(Line[Line((1, 2)), Line((2, 3)), Line((3, 4)), Line((4, 5)), Line((5, 6)), Line((6, 7)), Line((7, 8)), Line((8, 9)), Line((9, 10)), Line((10, 11))  …  Line((41, 42)), Line((42, 43)), Line((43, 44)), Line((44, 45)), Line((45, 46)), Line((46, 47)), Line((47, 48)), Line((48, 49)), Line((49, 50)), Line((50, 51))], Node{1, Float64}[Node{1, Float64}([-1.0]), Node{1, Float64}([-0.96]), Node{1, Float64}([-0.92]), Node{1, Float64}([-0.88]), Node{1, Float64}([-0.84]), Node{1, Float64}([-0.8]), Node{1, Float64}([-0.76]), Node{1, Float64}([-0.72]), Node{1, Float64}([-0.68]), Node{1, Float64}([-0.64])  …  Node{1, Float64}([0.64]), Node{1, Float64}([0.68]), Node{1, Float64}([0.72]), Node{1, Float64}([0.76]), Node{1, Float64}([0.8]), Node{1, Float64}([0.84]), Node{1, Float64}([0.88]), Node{1, Float64}([0.92]), Node{1, Float64}([0.96]), Node{1, Float64}([1.0])], Dict{String, OrderedCollections.OrderedSet{Int64}}(), Dict{String, OrderedCollections.OrderedSet{Int64}}(), Dict{String, OrderedCollections.OrderedSet{FacetIndex}}(&quot;left&quot; =&gt; OrderedCollections.OrderedSet{FacetIndex}([FacetIndex((1, 1))]), &quot;right&quot; =&gt; OrderedCollections.OrderedSet{FacetIndex}([FacetIndex((50, 2))])), Dict{String, OrderedCollections.OrderedSet{VertexIndex}}()), 51), true), [0.0001])
solver_ref: Base.RefValue{AbstractSolver}(CholeskySolver{TakahashiStrategy}([0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 1071×1071 LinearMapWithSqrt{Float64}, SparseArrays.CHOLMOD.Factor{Float64, Int64}
type:    LLt
method:  supernodal
maxnnz:  0
nnz:     72051
success: true
, TakahashiStrategy(), nothing, nothing))
)
</code></pre><p>To make things clearer, we are going to condition these GMRFs on a Gaussian initial condition to see how it propagates over time.</p><pre><code class="language-julia hljs">xs_ic = -0.99:0.01:0.99
ys_ic = exp.(-xs_ic .^ 2 / 0.2^2)
A_ic = evaluation_matrix(disc, [Tensors.Vec(x) for x in xs_ic])
A_ic = spatial_to_spatiotemporal(A_ic, 1, N_t)

x_adv_diff_dirichlet = condition_on_observations(x_adv_diff_dirichlet, A_ic, 1e8, ys_ic)
x_adv_diff_periodic = condition_on_observations(x_adv_diff_periodic, A_ic, 1e8, ys_ic)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LinearConditionalGMRF of size 1071 and solver LinearConditionalCholeskySolver{RBMCStrategy}</code></pre><p>First, check the initial observations:</p><pre><code class="language-julia hljs">plot(x_adv_diff_dirichlet, 1)</code></pre><img src="b0668f71.png" alt="Example block output"/><p>Now, let&#39;s see how the process evolves over time:</p><pre><code class="language-julia hljs">plot(x_adv_diff_dirichlet, N_t ÷ 2)</code></pre><img src="da4e341b.png" alt="Example block output"/><pre><code class="language-julia hljs">plot(x_adv_diff_dirichlet, N_t)</code></pre><img src="4f2833a9.png" alt="Example block output"/><p>Compare to this to the periodic case:</p><pre><code class="language-julia hljs">plot(x_adv_diff_periodic, N_t ÷ 2)</code></pre><img src="6e81fa5f.png" alt="Example block output"/><pre><code class="language-julia hljs">plot(x_adv_diff_periodic, N_t)</code></pre><img src="ecd0fec5.png" alt="Example block output"/><h2 id="Conclusion"><a class="docs-heading-anchor" href="#Conclusion">Conclusion</a><a id="Conclusion-1"></a><a class="docs-heading-anchor-permalink" href="#Conclusion" title="Permalink"></a></h2><p>We have seen how to specify more complex boundary conditions for GMRFs. All it takes is to construct the boundary conditions in Ferrite and add some noise.</p><p>For the sake of simplicity, this tutorial considered discretizations of a one-dimensional interval, but of course the same principles apply to higher dimensions and more complex geometries.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../spatiotemporal_modelling/">« Spatiotemporal Modelling with SPDEs</a><a class="docs-footer-nextpage" href="../../reference/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.1 on <span class="colophon-date" title="Tuesday 22 April 2025 19:17">Tuesday 22 April 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
