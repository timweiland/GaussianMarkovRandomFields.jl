import{_ as h,C as o,c as r,o as p,j as i,a as t,aA as n,G as a,w as l}from"./chunks/framework.YkF_Stjf.js";const F=JSON.parse('{"title":"Meshes","description":"","frontmatter":{},"headers":[],"relativePath":"reference/meshes.md","filePath":"reference/meshes.md","lastUpdated":null}'),d={name:"reference/meshes.md"},k={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""};function g(u,s,m,f,E,y){const e=o("Badge");return p(),r("div",null,[s[10]||(s[10]=i("h1",{id:"Meshes",tabindex:"-1"},[t("Meshes "),i("a",{class:"header-anchor",href:"#Meshes","aria-label":'Permalink to "Meshes {#Meshes}"'},"​")],-1)),s[11]||(s[11]=i("p",null,"Finite element method discretizations of SPDEs require a mesh. GaussianMarkovRandomFields provides some utility functions to create meshes for common use cases.",-1)),s[12]||(s[12]=i("p",null,[t("For a hands-on example meshing a 2D point cloud, check out the tutorial "),i("a",{href:"/GaussianMarkovRandomFields.jl/dev/tutorials/spatial_modelling_spdes#Spatial-Modelling-with-SPDEs"},"Spatial Modelling with SPDEs"),t(".")],-1)),i("details",k,[i("summary",null,[s[0]||(s[0]=i("a",{id:"GaussianMarkovRandomFields.generate_mesh",href:"#GaussianMarkovRandomFields.generate_mesh"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.generate_mesh")],-1)),s[1]||(s[1]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[4]||(s[4]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">generate_mesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GeometryBasics.MultiPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, buffer_width</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              interior_mesh_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              exterior_mesh_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> interior_mesh_size,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              element_order</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, save_path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate a mesh for a spatial point cloud, with a buffer to counteract boundary effects from the SPDE discretization.</p><p><strong>Input</strong></p><ul><li><p><code>mp</code> – MultiPoint object</p></li><li><p><code>buffer_width</code> – Width of the buffer around the convex hull</p></li><li><p><code>interior_mesh_size</code> – Mesh size inside the convex hull</p></li><li><p><code>exterior_mesh_size</code> – Mesh size outside the convex hull</p></li><li><p><code>element_order</code> – Order of the element basis functions</p></li><li><p><code>save_path</code> – Optional path to save the mesh</p></li></ul><p><strong>Output</strong></p><p>A <code>Ferrite.Grid</code> object</p><p><strong>Algorithm</strong></p><ol><li><p>Create the convex hull of the point cloud via LibGEOS</p></li><li><p>Create the buffer around the convex hull</p></li><li><p>Create a mesh for the buffered polygon using Gmsh</p></li><li><p>Transfer the Gmsh information to Ferrite</p></li></ol>`,8)),a(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[2]||(s[2]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/b617f7995618a6d08116bf544ec626e07080ed1e/src/mesh/scattered.jl#L22-L50",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1}),s[5]||(s[5]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">generate_mesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(points, buffer_width</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, interior_mesh_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              exterior_mesh_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> interior_mesh_size,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              element_order</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, save_path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate a mesh from a list of points using Gmsh.</p><p><strong>Input</strong></p><ul><li><p><code>points</code> – List of points</p></li><li><p><code>buffer_width</code> – Width of the buffer around the convex hull</p></li><li><p><code>interior_mesh_size</code> – Mesh size inside the convex hull</p></li><li><p><code>exterior_mesh_size</code> – Mesh size outside the convex hull</p></li><li><p><code>element_order</code> – Order of the elements</p></li><li><p><code>save_path</code> – Path to save the mesh</p></li></ul><p><strong>Output</strong></p><p>A Ferrite.Grid object</p>`,6)),a(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[3]||(s[3]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/b617f7995618a6d08116bf544ec626e07080ed1e/src/mesh/scattered.jl#L149-L168",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",c,[i("summary",null,[s[6]||(s[6]=i("a",{id:"GaussianMarkovRandomFields.create_inflated_rectangle",href:"#GaussianMarkovRandomFields.create_inflated_rectangle"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.create_inflated_rectangle")],-1)),s[7]||(s[7]=t()),a(e,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[9]||(s[9]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">create_inflated_rectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x0, y0, dx, dy, boundary_width, interior_mesh_size,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">exterior_mesh_size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> interior_mesh_size; element_order </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a triangular FEM discretization of a rectangle with an inflated boundary. Useful for FEM discretizations of SPDEs, where the domain is often artificially inflated to avoid undesirable boundary effects. Mesh has physical groups &quot;Domain&quot;, &quot;Interior&quot;, &quot;Interior boundary&quot; and possibly &quot;Exterior boundary&quot;.</p><p><strong>Arguments</strong></p><ul><li><p><code>x0::Real</code>: x-coordinate of the bottom-left corner of the rectangle</p></li><li><p><code>y0::Real</code>: y-coordinate of the bottom-left corner of the rectangle</p></li><li><p><code>dx::Real</code>: Width of the rectangle</p></li><li><p><code>dy::Real</code>: Height of the rectangle</p></li><li><p><code>boundary_width::Real</code>: Width of the inflated boundary. If 0.0, mesh will not be inflated at all.</p></li><li><p><code>interior_mesh_size::Real</code>: Mesh size in the interior of the rectangle</p></li><li><p><code>exterior_mesh_size::Real</code>: Mesh size in the exterior of the rectangle</p></li><li><p><code>element_order::Int</code>: Order of the FEM elements</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>grid::Ferrite.Grid</code>: the FEM discretization of the rectangle</p></li><li><p><code>boundary_tags::Vector{Int}</code>: the indices of the boundary nodes</p></li></ul>`,6)),a(e,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[8]||(s[8]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/b617f7995618a6d08116bf544ec626e07080ed1e/src/mesh/rectangle.jl#L5-L30",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const b=h(d,[["render",g]]);export{F as __pageData,b as default};
