import{_ as o,C as r,c as p,o as d,j as i,a as e,aA as n,G as t,w as l}from"./chunks/framework.B28kaWcy.js";const z=JSON.parse('{"title":"GMRFs","description":"","frontmatter":{},"headers":[],"relativePath":"reference/gmrfs.md","filePath":"reference/gmrfs.md","lastUpdated":null}'),h={name:"reference/gmrfs.md"},k={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},b={class:"jldocstring custom-block",open:""},y={class:"jldocstring custom-block",open:""},F={class:"jldocstring custom-block",open:""},_={class:"jldocstring custom-block",open:""},E={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""},f={class:"jldocstring custom-block",open:""},M={class:"jldocstring custom-block",open:""},R={class:"jldocstring custom-block",open:""},C={class:"jldocstring custom-block",open:""},T={class:"jldocstring custom-block",open:""},A={class:"jldocstring custom-block",open:""},j={class:"jldocstring custom-block",open:""},G={class:"jldocstring custom-block",open:""},x={class:"jldocstring custom-block",open:""},S={class:"jldocstring custom-block",open:""},D={class:"jldocstring custom-block",open:""};function L(V,s,B,I,P,w){const a=r("Badge");return d(),p("div",null,[s[92]||(s[92]=i("h1",{id:"GMRFs",tabindex:"-1"},[e("GMRFs "),i("a",{class:"header-anchor",href:"#GMRFs","aria-label":'Permalink to "GMRFs {#GMRFs}"'},"​")],-1)),i("details",k,[i("summary",null,[s[0]||(s[0]=i("a",{id:"GaussianMarkovRandomFields.AbstractGMRF",href:"#GaussianMarkovRandomFields.AbstractGMRF"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.AbstractGMRF")],-1)),s[1]||(s[1]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[3]||(s[3]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractGMRF</span></span></code></pre></div><p>A <a href="https://en.wikipedia.org/wiki/Markov_random_field#Gaussian" target="_blank" rel="noreferrer">Gaussian Markov Random Field</a> (GMRF) is a special case of a multivariate normal distribution where the precision matrix is sparse. The zero entries in the precision correspond to conditional independencies.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[2]||(s[2]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/gmrf.jl#L59-L65",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",c,[i("summary",null,[s[4]||(s[4]=i("a",{id:"GaussianMarkovRandomFields.GMRF",href:"#GaussianMarkovRandomFields.GMRF"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.GMRF")],-1)),s[5]||(s[5]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[7]||(s[7]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mean, precision, alg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LinearSolve</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">DefaultLinearSolver</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); Q_sqrt</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rbmc_strategy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RBMCStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), linsolve_cache</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>A Gaussian Markov Random Field with mean <code>mean</code> and precision matrix <code>precision</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>mean::AbstractVector</code>: The mean vector of the GMRF.</p></li><li><p><code>precision::Union{LinearMap, AbstractMatrix}</code>: The precision matrix (inverse covariance) of the GMRF.</p></li><li><p><code>alg</code>: LinearSolve algorithm to use for linear system solving. Defaults to <code>LinearSolve.DefaultLinearSolver()</code>.</p></li><li><p><code>Q_sqrt::Union{Nothing, AbstractMatrix}</code>: Square root of precision matrix Q, used for sampling when algorithm doesn&#39;t support backward solve.</p></li><li><p><code>rbmc_strategy</code>: RBMC strategy for marginal variance computation when selected inversion is unavailable. Defaults to <code>RBMCStrategy(1000)</code>.</p></li><li><p><code>linsolve_cache::Union{Nothing, LinearSolve.LinearCache}</code>: Existing LinearSolve cache to reuse. If <code>nothing</code>, creates a new cache. Useful for iterative algorithms requiring factorization reuse.</p></li></ul><p><strong>Type Parameters</strong></p><ul><li><p><code>T&lt;:Real</code>: The numeric type (e.g., Float64).</p></li><li><p><code>PrecisionMap&lt;:Union{LinearMap{T}, AbstractMatrix{T}}</code>: The type of the precision matrix.</p></li></ul><p><strong>Fields</strong></p><ul><li><p><code>mean::Vector{T}</code>: The mean vector.</p></li><li><p><code>precision::PrecisionMap</code>: The precision matrix.</p></li><li><p><code>Q_sqrt::Union{Nothing, AbstractMatrix{T}}</code>: Square root of precision matrix for sampling.</p></li><li><p><code>linsolve_cache::LinearSolve.LinearCache</code>: The LinearSolve cache for efficient operations.</p></li><li><p><code>rbmc_strategy</code>: RBMC strategy for variance computation fallback.</p></li></ul><p><strong>Notes</strong></p><p>The LinearSolve cache is constructed automatically (if not provided) and is used to compute means, variances, samples, and other GMRF quantities efficiently. The algorithm choice determines which optimization strategies (selected inversion, backward solve) are available. When selected inversion is not supported, marginal variances are computed using the configured RBMC strategy. Providing an existing <code>linsolve_cache</code> enables factorization reuse in iterative algorithms.</p>',10)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[6]||(s[6]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/gmrf.jl#L113-L143",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",u,[i("summary",null,[s[8]||(s[8]=i("a",{id:"GaussianMarkovRandomFields.precision_map",href:"#GaussianMarkovRandomFields.precision_map"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.precision_map")],-1)),s[9]||(s[9]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[12]||(s[12]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">precision_map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractGMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the precision (inverse covariance) map of the GMRF.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[10]||(s[10]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/gmrf.jl#L71-L75",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1}),s[13]||(s[13]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">precision_map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ConstrainedGMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the precision map of the constrained GMRF. Note: This is singular due to the constraints, but we return it for interface compliance. In practice, this should rarely be used directly due to singularity.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[11]||(s[11]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/arithmetic/constrained.jl#L132-L138",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",g,[i("summary",null,[s[14]||(s[14]=i("a",{id:"GaussianMarkovRandomFields.precision_matrix",href:"#GaussianMarkovRandomFields.precision_matrix"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.precision_matrix")],-1)),s[15]||(s[15]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[18]||(s[18]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">precision_matrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractGMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the precision (inverse covariance) matrix of the GMRF.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[16]||(s[16]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/gmrf.jl#L78-L82",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1}),s[19]||(s[19]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">precision_matrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(model</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">LatentModel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; kwargs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Construct the precision matrix for the model given hyperparameter values.</p><p><strong>Arguments</strong></p><ul><li><p><code>model</code>: The LatentModel instance</p></li><li><p><code>kwargs...</code>: Hyperparameter values as keyword arguments</p></li></ul><p><strong>Returns</strong></p><p>A precision matrix (AbstractMatrix or LinearMap) for use in GMRF construction.</p>',6)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[17]||(s[17]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/latent_models/latent_model.jl#L66-L77",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",m,[i("summary",null,[s[20]||(s[20]=i("a",{id:"GaussianMarkovRandomFields.InformationVector",href:"#GaussianMarkovRandomFields.InformationVector"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.InformationVector")],-1)),s[21]||(s[21]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[23]||(s[23]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">InformationVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractVector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Wrapper type for information vectors (Q * μ) used in GMRF construction. This allows distinguishing between constructors that take mean vectors vs information vectors.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[22]||(s[22]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/gmrf.jl#L32-L38",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",b,[i("summary",null,[s[24]||(s[24]=i("a",{id:"GaussianMarkovRandomFields.information_vector",href:"#GaussianMarkovRandomFields.information_vector"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.information_vector")],-1)),s[25]||(s[25]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[27]||(s[27]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">information_vector</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the information vector (Q * μ) for the GMRF. If stored, returns the cached value; otherwise computes it.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[26]||(s[26]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/gmrf.jl#L244-L249",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[93]||(s[93]=i("h2",{id:"Metadata",tabindex:"-1"},[e("Metadata "),i("a",{class:"header-anchor",href:"#Metadata","aria-label":'Permalink to "Metadata {#Metadata}"'},"​")],-1)),i("details",y,[i("summary",null,[s[28]||(s[28]=i("a",{id:"GaussianMarkovRandomFields.MetaGMRF",href:"#GaussianMarkovRandomFields.MetaGMRF"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.MetaGMRF")],-1)),s[29]||(s[29]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[31]||(s[31]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">MetaGMRF{M </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GMRFMetadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, T, P, G </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractGMRF{T, P}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> AbstractGMRF{T, P}</span></span></code></pre></div><p>A wrapper that combines a core GMRF with metadata of type M. This allows for specialized behavior based on the metadata type while preserving the computational efficiency of the underlying GMRF.</p><p><strong>Fields</strong></p><ul><li><p><code>gmrf::G</code>: The core computational GMRF (parametric type)</p></li><li><p><code>metadata::M</code>: Domain-specific metadata</p></li></ul><p><strong>Usage</strong></p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Define metadata types</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> SpatialMetadata </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GMRFMetadata</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    coordinates</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Matrix{Float64}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    boundary_info</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Vector{Int}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Create wrapped GMRF</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">meta_gmrf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> MetaGMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(my_gmrf, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">SpatialMetadata</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(coords, boundary))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Dispatch on metadata type for specialized behavior</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> some_spatial_operation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mgmrf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">MetaGMRF{SpatialMetadata}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Access coordinates via mgmrf.metadata.coordinates</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    # Access GMRF via mgmrf.gmrf</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">end</span></span></code></pre></div>`,6)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[30]||(s[30]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/metagmrf.jl#L14-L42",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",F,[i("summary",null,[s[32]||(s[32]=i("a",{id:"GaussianMarkovRandomFields.GMRFMetadata",href:"#GaussianMarkovRandomFields.GMRFMetadata"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.GMRFMetadata")],-1)),s[33]||(s[33]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[35]||(s[35]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">GMRFMetadata</span></span></code></pre></div><p>Abstract base type for metadata that can be attached to GMRFs via MetaGMRF. Concrete subtypes should contain domain-specific information about the GMRF structure, coordinates, naming, etc.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[34]||(s[34]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/metagmrf.jl#L5-L11",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[94]||(s[94]=i("h2",{id:"Arithmetic",tabindex:"-1"},[e("Arithmetic "),i("a",{class:"header-anchor",href:"#Arithmetic","aria-label":'Permalink to "Arithmetic {#Arithmetic}"'},"​")],-1)),i("details",_,[i("summary",null,[s[36]||(s[36]=i("a",{id:"GaussianMarkovRandomFields.condition_on_observations",href:"#GaussianMarkovRandomFields.condition_on_observations"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.condition_on_observations")],-1)),s[37]||(s[37]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[39]||(s[39]=n("<p>&quot; condition_on_observations( x::GMRF, A::Union{AbstractMatrix,LinearMap}, Q_ϵ::Union{AbstractMatrix,LinearMap,Real}, y::AbstractVector=zeros(size(A)[1]), b::AbstractVector=zeros(size(A)[1]); # solver_blueprint parameter removed - no longer needed with LinearSolve )</p><p>Condition a GMRF <code>x</code> on observations <code>y = A * x + b + ϵ</code> where <code>ϵ ~ N(0, Q_ϵ⁻¹)</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>x::GMRF</code>: The GMRF to condition on.</p></li><li><p><code>A::Union{AbstractMatrix,LinearMap}</code>: The matrix <code>A</code>.</p></li><li><p><code>Q_ϵ::Union{AbstractMatrix,LinearMap, Real}</code>: The precision matrix of the noise term <code>ϵ</code>. In case a real number is provided, it is interpreted as a scalar multiple of the identity matrix.</p></li><li><p><code>y::AbstractVector=zeros(size(A)[1])</code>: The observations <code>y</code>; optional.</p></li><li><p><code>b::AbstractVector=zeros(size(A)[1])</code>: Offset vector <code>b</code>; optional.</p></li></ul><p><strong>Keyword arguments</strong></p><p><strong>Note: solver_blueprint parameter removed - no longer needed with LinearSolve.jl</strong></p><p><strong>Returns</strong></p><p>A <code>GMRF</code> object representing the conditional GMRF <code>x | (y = A * x + b + ϵ)</code>.</p><p><strong>Notes</strong></p><p>This function is deprecated. Use <code>linear_condition</code>.</p>",10)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[38]||(s[38]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/arithmetic/condition/linear.jl#L77-L107",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",E,[i("summary",null,[s[40]||(s[40]=i("a",{id:"GaussianMarkovRandomFields.linear_condition",href:"#GaussianMarkovRandomFields.linear_condition"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.linear_condition")],-1)),s[41]||(s[41]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[43]||(s[43]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">linear_condition</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(gmrf</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; A, Q_ϵ, y, b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">zeros</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(A, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)), obs_precision_contrib</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Condition a GMRF on linear observations y = A * x + b + ϵ where ϵ ~ N(0, Q_ϵ^(-1)).</p><p><strong>Arguments</strong></p><ul><li><p><code>gmrf::GMRF</code>: The prior GMRF</p></li><li><p><code>A::Union{AbstractMatrix, LinearMap}</code>: Observation matrix</p></li><li><p><code>Q_ϵ::Union{AbstractMatrix, LinearMap}</code>: Precision matrix of observation noise</p></li><li><p><code>y::AbstractVector</code>: Observation values</p></li><li><p><code>b::AbstractVector</code>: Offset vector (defaults to zeros)</p></li><li><p><code>obs_precision_contrib</code>: Precomputed A&#39; * Q_ϵ * A (optional optimization)</p></li></ul><p><strong>Returns</strong></p><p>A new <code>GMRF</code> representing the posterior distribution with updated mean and precision.</p><p><strong>Performance Optimization</strong></p><p>When A has special structure (e.g., index selection), users can precompute A&#39; * Q_ϵ * A more efficiently and pass it to avoid redundant computation.</p><p><strong>Notes</strong></p><p>Uses information vector arithmetic for efficient conditioning without intermediate solves.</p>',10)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[42]||(s[42]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/arithmetic/condition/linear.jl#L25-L47",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",v,[i("summary",null,[s[44]||(s[44]=i("a",{id:"GaussianMarkovRandomFields.joint_gmrf",href:"#GaussianMarkovRandomFields.joint_gmrf"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.joint_gmrf")],-1)),s[45]||(s[45]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[47]||(s[47]=n("<p>&quot; joint_gmrf( x1::AbstractGMRF, A::AbstractMatrix, Q_ϵ::AbstractMatrix, b::AbstractVector=spzeros(size(A)[1]) )</p><p>Return the joint GMRF of <code>x1</code> and <code>x2 = A * x1 + b + ϵ</code> where <code>ϵ ~ N(0, Q_ϵ⁻¹)</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>x1::AbstractGMRF</code>: The first GMRF.</p></li><li><p><code>A::AbstractMatrix</code>: The matrix <code>A</code>.</p></li><li><p><code>Q_ϵ::AbstractMatrix</code>: The precision matrix of the noise term <code>ϵ</code>.</p></li><li><p><code>b::AbstractVector=spzeros(size(A)[1])</code>: Offset vector <code>b</code>; optional.</p></li></ul><p><strong>Returns</strong></p><p>A <code>GMRF</code> object representing the joint GMRF of <code>x1</code> and <code>x2 = A * x1 + b + ϵ</code>.</p>",6)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[46]||(s[46]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/arithmetic/joint.jl#L5-L24",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[95]||(s[95]=i("h2",{id:"Spatiotemporal-setting",tabindex:"-1"},[e("Spatiotemporal setting "),i("a",{class:"header-anchor",href:"#Spatiotemporal-setting","aria-label":'Permalink to "Spatiotemporal setting {#Spatiotemporal-setting}"'},"​")],-1)),s[96]||(s[96]=i("h3",{id:"Types",tabindex:"-1"},[e("Types "),i("a",{class:"header-anchor",href:"#Types","aria-label":'Permalink to "Types {#Types}"'},"​")],-1)),i("details",f,[i("summary",null,[s[48]||(s[48]=i("a",{id:"GaussianMarkovRandomFields.AbstractSpatiotemporalGMRF",href:"#GaussianMarkovRandomFields.AbstractSpatiotemporalGMRF"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.AbstractSpatiotemporalGMRF")],-1)),s[49]||(s[49]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[51]||(s[51]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractSpatiotemporalGMRF</span></span></code></pre></div><p>A spatiotemporal GMRF is a GMRF that explicitly encodes the spatial and temporal structure of the underlying random field. All time points are modelled in one joint GMRF. It provides utilities to get statistics, draw samples and get the spatial discretization at a given time.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[50]||(s[50]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/spdes/spatiotemporal/spatiotemporal_gmrf.jl#L20-L28",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",M,[i("summary",null,[s[52]||(s[52]=i("a",{id:"GaussianMarkovRandomFields.ImplicitEulerConstantMeshSTGMRF",href:"#GaussianMarkovRandomFields.ImplicitEulerConstantMeshSTGMRF"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.ImplicitEulerConstantMeshSTGMRF")],-1)),s[53]||(s[53]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[55]||(s[55]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ImplicitEulerConstantMeshSTGMRF</span></span></code></pre></div><p>A spatiotemporal GMRF with constant spatial discretization and an implicit Euler discretization of the temporal dynamics. Uses MetaGMRF for clean type structure.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[54]||(s[54]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/spdes/spatiotemporal/constant_mesh.jl#L36-L41",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",R,[i("summary",null,[s[56]||(s[56]=i("a",{id:"GaussianMarkovRandomFields.ConcreteConstantMeshSTGMRF",href:"#GaussianMarkovRandomFields.ConcreteConstantMeshSTGMRF"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.ConcreteConstantMeshSTGMRF")],-1)),s[57]||(s[57]=e()),t(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),s[59]||(s[59]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ConcreteConstantMeshSTGMRF</span></span></code></pre></div><p>A concrete implementation of a spatiotemporal GMRF with constant spatial discretization. Uses MetaGMRF for clean type structure.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[58]||(s[58]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/spdes/spatiotemporal/constant_mesh.jl#L44-L49",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[97]||(s[97]=i("h3",{id:"Quantities",tabindex:"-1"},[e("Quantities "),i("a",{class:"header-anchor",href:"#Quantities","aria-label":'Permalink to "Quantities {#Quantities}"'},"​")],-1)),i("details",C,[i("summary",null,[s[60]||(s[60]=i("a",{id:"GaussianMarkovRandomFields.N_t",href:"#GaussianMarkovRandomFields.N_t"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.N_t")],-1)),s[61]||(s[61]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[63]||(s[63]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">N_t</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractSpatiotemporalGMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the number of time points in the spatiotemporal GMRF.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[62]||(s[62]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/spdes/spatiotemporal/spatiotemporal_gmrf.jl#L31-L35",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",T,[i("summary",null,[s[64]||(s[64]=i("a",{id:"GaussianMarkovRandomFields.time_means",href:"#GaussianMarkovRandomFields.time_means"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.time_means")],-1)),s[65]||(s[65]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[67]||(s[67]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">time_means</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractSpatiotemporalGMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the means of the spatiotemporal GMRF at each time point.</p><p><strong>Returns</strong></p><ul><li>A vector of means of length Nₜ, one for each time point.</li></ul>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[66]||(s[66]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/spdes/spatiotemporal/spatiotemporal_gmrf.jl#L38-L45",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",A,[i("summary",null,[s[68]||(s[68]=i("a",{id:"GaussianMarkovRandomFields.time_vars",href:"#GaussianMarkovRandomFields.time_vars"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.time_vars")],-1)),s[69]||(s[69]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[71]||(s[71]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">time_vars</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractSpatiotemporalGMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the marginal variances of the spatiotemporal GMRF at each time point.</p><p><strong>Returns</strong></p><ul><li>A vector of marginal variances of length Nₜ, one for each time point.</li></ul>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[70]||(s[70]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/spdes/spatiotemporal/spatiotemporal_gmrf.jl#L48-L55",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",j,[i("summary",null,[s[72]||(s[72]=i("a",{id:"GaussianMarkovRandomFields.time_stds",href:"#GaussianMarkovRandomFields.time_stds"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.time_stds")],-1)),s[73]||(s[73]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[75]||(s[75]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">time_stds</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractSpatiotemporalGMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the marginal standard deviations of the spatiotemporal GMRF at each time point.</p><p><strong>Returns</strong></p><ul><li>A vector of marginal standard deviations of length Nₜ, one for each time point.</li></ul>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[74]||(s[74]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/spdes/spatiotemporal/spatiotemporal_gmrf.jl#L58-L65",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",G,[i("summary",null,[s[76]||(s[76]=i("a",{id:"GaussianMarkovRandomFields.time_rands",href:"#GaussianMarkovRandomFields.time_rands"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.time_rands")],-1)),s[77]||(s[77]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[79]||(s[79]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">time_rands</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractSpatiotemporalGMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, rng</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractRNG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Draw samples from the spatiotemporal GMRF at each time point.</p><p><strong>Returns</strong></p><ul><li>A vector of sample values of length Nₜ, one sample value vector for each time point.</li></ul>',4)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[78]||(s[78]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/spdes/spatiotemporal/spatiotemporal_gmrf.jl#L68-L76",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",x,[i("summary",null,[s[80]||(s[80]=i("a",{id:"GaussianMarkovRandomFields.discretization_at_time",href:"#GaussianMarkovRandomFields.discretization_at_time"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.discretization_at_time")],-1)),s[81]||(s[81]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[83]||(s[83]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">discretization_at_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractSpatiotemporalGMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Return the spatial discretization at time <code>t</code>.</p>',2)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[82]||(s[82]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/spdes/spatiotemporal/spatiotemporal_gmrf.jl#L80-L84",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s[98]||(s[98]=i("h3",{id:"Utilities",tabindex:"-1"},[e("Utilities "),i("a",{class:"header-anchor",href:"#Utilities","aria-label":'Permalink to "Utilities {#Utilities}"'},"​")],-1)),i("details",S,[i("summary",null,[s[84]||(s[84]=i("a",{id:"GaussianMarkovRandomFields.spatial_to_spatiotemporal",href:"#GaussianMarkovRandomFields.spatial_to_spatiotemporal"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.spatial_to_spatiotemporal")],-1)),s[85]||(s[85]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[87]||(s[87]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">spatial_to_spatiotemporal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    spatial_matrix</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractMatrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    t_idx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    N_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Make a spatial matrix applicable to a spatiotemporal system at time index <code>t_idx</code>. Results in a matrix that selects the spatial information exactly at time <code>t_idx</code>.</p><p><strong>Arguments</strong></p><ul><li><p><code>spatial_matrix::AbstractMatrix</code>: The spatial matrix.</p></li><li><p><code>t_idx::Integer</code>: The time index.</p></li><li><p><code>N_t::Integer</code>: The number of time points.</p></li></ul>`,4)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[86]||(s[86]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/spdes/spatiotemporal/utils.jl#L8-L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),i("details",D,[i("summary",null,[s[88]||(s[88]=i("a",{id:"GaussianMarkovRandomFields.kronecker_product_spatiotemporal_model",href:"#GaussianMarkovRandomFields.kronecker_product_spatiotemporal_model"},[i("span",{class:"jlbinding"},"GaussianMarkovRandomFields.kronecker_product_spatiotemporal_model")],-1)),s[89]||(s[89]=e()),t(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),s[91]||(s[91]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">kronecker_product_spatiotemporal_model</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Q_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractMatrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    Q_s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AbstractMatrix</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    spatial_disc</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">FEMDiscretization</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    algorithm </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a spatiotemporal GMRF through a Kronecker product of the temporal and spatial precision matrices.</p><p><strong>Arguments</strong></p><ul><li><p><code>Q_t::AbstractMatrix</code>: The temporal precision matrix.</p></li><li><p><code>Q_s::AbstractMatrix</code>: The spatial precision matrix.</p></li><li><p><code>spatial_disc::FEMDiscretization</code>: The spatial discretization.</p></li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>algorithm</code>: The LinearSolve algorithm to use.</li></ul>`,6)),t(a,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...s[90]||(s[90]=[i("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/57a7c6c1c602e25080c466e0dade2d87e250b1b3/src/spdes/spatiotemporal/product.jl#L5-L23",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const O=o(h,[["render",L]]);export{z as __pageData,O as default};
