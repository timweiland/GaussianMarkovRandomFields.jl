import{_ as n,C as r,c as d,o as p,aA as t,j as s,G as i,a as l,w as o}from"./chunks/framework.B28kaWcy.js";const T=JSON.parse('{"title":"Solvers","description":"","frontmatter":{},"headers":[],"relativePath":"reference/solvers.md","filePath":"reference/solvers.md","lastUpdated":null}'),h={name:"reference/solvers.md"},c={class:"jldocstring custom-block",open:""},u={class:"jldocstring custom-block",open:""},g={class:"jldocstring custom-block",open:""},k={class:"jldocstring custom-block",open:""},m={class:"jldocstring custom-block",open:""},v={class:"jldocstring custom-block",open:""};function b(f,e,y,_,C,E){const a=r("Badge");return p(),d("div",null,[e[30]||(e[30]=t(`<h1 id="Solvers" tabindex="-1">Solvers <a class="header-anchor" href="#Solvers" aria-label="Permalink to &quot;Solvers {#Solvers}&quot;">​</a></h1><p>Fundamentally, all interesting quantities of GMRFs (samples, marginal variances, posterior means, ...) must be computed through <strong>sparse linear algebra</strong>. GaussianMarkovRandomFields.jl uses <a href="https://github.com/SciML/LinearSolve.jl" target="_blank" rel="noreferrer">LinearSolve.jl</a> as the backend for all linear algebra operations, providing access to a wide range of modern solvers and preconditioners while maintaining a unified interface. Our goal is to provide sane defaults that &quot;just work&quot; for most users, while still allowing power users to customize the behavior through LinearSolve.jl algorithms. Read further to learn about the available capabilities and how to use them.</p><h2 id="Direct-Methods-Cholesky,-LU" tabindex="-1">Direct Methods (Cholesky, LU) <a class="header-anchor" href="#Direct-Methods-Cholesky,-LU" aria-label="Permalink to &quot;Direct Methods (Cholesky, LU) {#Direct-Methods-Cholesky,-LU}&quot;">​</a></h2><p><a href="https://github.com/DrTimothyAldenDavis/SuiteSparse" target="_blank" rel="noreferrer">CHOLMOD</a> and other direct solvers are state-of-the-art methods for sparse linear systems. LinearSolve.jl automatically selects appropriate direct methods (typically Cholesky for symmetric positive definite systems like GMRF precision matrices) to compute factorizations of the precision matrix, which are then leveraged to draw samples and compute posterior means. Marginal variances are computed using selected inversion when available, or RBMC as a fallback.</p><h2 id="Pardiso" tabindex="-1">Pardiso <a class="header-anchor" href="#Pardiso" aria-label="Permalink to &quot;Pardiso {#Pardiso}&quot;">​</a></h2><p><a href="https://panua.ch/pardiso/" target="_blank" rel="noreferrer">Pardiso</a> is a state-of-the-art direct solver for sparse linear systems with excellent performance on large-dimensional GMRFs and highly efficient methods for marginal variance computation.</p><p>To use Pardiso, you need to set up and load <a href="https://github.com/JuliaSparse/Pardiso.jl" target="_blank" rel="noreferrer">Pardiso.jl</a>, then specify <code>alg=LinearSolve.PardisoJL()</code> when creating your GMRF:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Pardiso, LinearSolve</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gmrf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(μ, Q, alg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LinearSolve</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PardisoJL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>See the <a href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/#LinearSolve.PardisoJL" target="_blank" rel="noreferrer">LinearSolve.jl documentation</a> for more information about PardisoJL algorithm options.</p><h2 id="Iterative-Methods-CG,-GMRES" tabindex="-1">Iterative Methods (CG, GMRES) <a class="header-anchor" href="#Iterative-Methods-CG,-GMRES" aria-label="Permalink to &quot;Iterative Methods (CG, GMRES) {#Iterative-Methods-CG,-GMRES}&quot;">​</a></h2><p>The Conjugate Gradient (CG) method and other iterative methods are efficient approaches for solving large sparse symmetric positive-definite linear systems. LinearSolve.jl provides access to various iterative solvers that can be used for large-scale GMRFs where direct methods become prohibitively expensive.</p><p>For symmetric systems like GMRFs, CG-based methods are typically most appropriate:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> LinearSolve</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gmrf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(μ, Q, alg</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">LinearSolve</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">KrylovJL_CG</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><h2 id="Variance-Computation-Strategies" tabindex="-1">Variance Computation Strategies <a class="header-anchor" href="#Variance-Computation-Strategies" aria-label="Permalink to &quot;Variance Computation Strategies {#Variance-Computation-Strategies}&quot;">​</a></h2><p>Fundamentally, computing marginal variances of GMRFs is not trivial, as it requires computing the diagonal entries of the covariance matrix (which is the inverse of the precision matrix).</p><p><strong>Selected Inversion</strong> (including Takahashi recursions) is a highly accurate and stable method for computing these variances when available for the chosen algorithm. This is automatically used when supported.</p><p>When selected inversion is not available, the package automatically falls back to <strong>RBMC</strong> (Rao-Blackwellized Monte Carlo), a sampling-based approach that is less accurate but can be much faster for large GMRFs.</p>`,17)),s("details",c,[s("summary",null,[e[0]||(e[0]=s("a",{id:"GaussianMarkovRandomFields.AbstractVarianceStrategy",href:"#GaussianMarkovRandomFields.AbstractVarianceStrategy"},[s("span",{class:"jlbinding"},"GaussianMarkovRandomFields.AbstractVarianceStrategy")],-1)),e[1]||(e[1]=l()),i(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[3]||(e[3]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">AbstractVarianceStrategy</span></span></code></pre></div><p>An abstract type for a strategy to compute the variance of a GMRF.</p>',2)),i(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[2]||(e[2]=[s("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/97b26741f01925cdd02ec7f634f45a0804af14e2/src/typedefs.jl#L5-L9",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",u,[s("summary",null,[e[4]||(e[4]=s("a",{id:"GaussianMarkovRandomFields.RBMCStrategy",href:"#GaussianMarkovRandomFields.RBMCStrategy"},[s("span",{class:"jlbinding"},"GaussianMarkovRandomFields.RBMCStrategy")],-1)),e[5]||(e[5]=l()),i(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[7]||(e[7]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">RBMCStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n_samples; rng)</span></span></code></pre></div><p>Rao-Blackwellized Monte Carlo estimator of a GMRF&#39;s marginal variances based on [<a href="/GaussianMarkovRandomFields.jl/dev/bibliography#Siden2018">3</a>]. Particularly useful in large-scale regimes where Takahashi recursions may be too expensive.</p><p><strong>Arguments</strong></p><ul><li><code>n_samples::Int</code>: Number of samples to draw.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><code>rng::Random.AbstractRNG = Random.default_rng()</code>: Random number generator.</li></ul>',6)),i(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[6]||(e[6]=[s("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/97b26741f01925cdd02ec7f634f45a0804af14e2/src/solvers/rbmc.jl#L8-L21",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",g,[s("summary",null,[e[8]||(e[8]=s("a",{id:"GaussianMarkovRandomFields.BlockRBMCStrategy",href:"#GaussianMarkovRandomFields.BlockRBMCStrategy"},[s("span",{class:"jlbinding"},"GaussianMarkovRandomFields.BlockRBMCStrategy")],-1)),e[9]||(e[9]=l()),i(a,{type:"info",class:"jlObjectType jlType",text:"Type"})]),e[11]||(e[11]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">BlockRBMCStrategy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(n_samples; rng, enclosure_size)</span></span></code></pre></div><p>Block Rao-Blackwellized Monte Carlo estimator of a GMRF&#39;s marginal variances based on [<a href="/GaussianMarkovRandomFields.jl/dev/bibliography#Siden2018">3</a>]. Achieves faster convergence than plain RBMC by considering blocks of nodes rather than individual nodes, thus integrating more information about the precision matrix. <code>enclosure_size</code> specifies the size of these blocks. Larger values lead to faster convergence (in terms of the number of samples) at the cost of increased compute. Thus, one should aim for a sweet spot between sampling costs and block operation costs.</p><p><strong>Arguments</strong></p><ul><li><code>n_samples::Int</code>: Number of samples to draw.</li></ul><p><strong>Keyword arguments</strong></p><ul><li><p><code>rng::Random.AbstractRNG = Random.default_rng()</code>: Random number generator.</p></li><li><p><code>enclosure_size::Int = 1</code>: Size of the blocks.</p></li></ul>',6)),i(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[10]||(e[10]=[s("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/97b26741f01925cdd02ec7f634f45a0804af14e2/src/solvers/rbmc.jl#L31-L51",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[31]||(e[31]=s("h2",{id:"Advanced-Operations",tabindex:"-1"},[l("Advanced Operations "),s("a",{class:"header-anchor",href:"#Advanced-Operations","aria-label":'Permalink to "Advanced Operations {#Advanced-Operations}"'},"​")],-1)),s("details",k,[s("summary",null,[e[12]||(e[12]=s("a",{id:"GaussianMarkovRandomFields.logdet_cov",href:"#GaussianMarkovRandomFields.logdet_cov"},[s("span",{class:"jlbinding"},"GaussianMarkovRandomFields.logdet_cov")],-1)),e[13]||(e[13]=l()),i(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[16]||(e[16]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">logdet_cov</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(linsolve, alg)</span></span></code></pre></div><p>Compute the log determinant of the covariance matrix (inverse of precision). Dispatches on the algorithm type.</p>',2)),i(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[14]||(e[14]=[s("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/97b26741f01925cdd02ec7f634f45a0804af14e2/src/solvers/logdet.jl#L6-L11",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1}),e[17]||(e[17]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">logdet_cov</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(linsolve)</span></span></code></pre></div><p>Convenience function that dispatches to logdet_cov(linsolve, linsolve.alg).</p>',2)),i(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[15]||(e[15]=[s("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/97b26741f01925cdd02ec7f634f45a0804af14e2/src/solvers/logdet.jl#L17-L21",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",m,[s("summary",null,[e[18]||(e[18]=s("a",{id:"GaussianMarkovRandomFields.selinv",href:"#GaussianMarkovRandomFields.selinv"},[s("span",{class:"jlbinding"},"GaussianMarkovRandomFields.selinv")],-1)),e[19]||(e[19]=l()),i(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[22]||(e[22]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">selinv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(linsolve, alg)</span></span></code></pre></div><p>Compute the full selected inverse matrix using selected inversion. Dispatches on the algorithm type.</p>',2)),i(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[20]||(e[20]=[s("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/97b26741f01925cdd02ec7f634f45a0804af14e2/src/solvers/selinv.jl#L48-L53",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1}),e[23]||(e[23]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">selinv</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(linsolve)</span></span></code></pre></div><p>Convenience function that dispatches to selinv(linsolve, linsolve.alg).</p>',2)),i(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[21]||(e[21]=[s("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/97b26741f01925cdd02ec7f634f45a0804af14e2/src/solvers/selinv.jl#L59-L63",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",v,[s("summary",null,[e[24]||(e[24]=s("a",{id:"GaussianMarkovRandomFields.backward_solve",href:"#GaussianMarkovRandomFields.backward_solve"},[s("span",{class:"jlbinding"},"GaussianMarkovRandomFields.backward_solve")],-1)),e[25]||(e[25]=l()),i(a,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[28]||(e[28]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">backward_solve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(linsolve, x, alg)</span></span></code></pre></div><p>Perform backward solve L^T \\ x where L is the Cholesky factor. Dispatches on the algorithm type.</p>',2)),i(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[26]||(e[26]=[s("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/97b26741f01925cdd02ec7f634f45a0804af14e2/src/solvers/backward_solve.jl#L29-L34",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1}),e[29]||(e[29]=t('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">backward_solve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(linsolve, x)</span></span></code></pre></div><p>Convenience function that dispatches to backward_solve(linsolve, x, linsolve.alg).</p>',2)),i(a,{type:"info",class:"source-link",text:"source"},{default:o(()=>[...e[27]||(e[27]=[s("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/97b26741f01925cdd02ec7f634f45a0804af14e2/src/solvers/backward_solve.jl#L40-L44",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),e[32]||(e[32]=t('<h2 id="Choosing-a-Solver" tabindex="-1">Choosing a Solver <a class="header-anchor" href="#Choosing-a-Solver" aria-label="Permalink to &quot;Choosing a Solver {#Choosing-a-Solver}&quot;">​</a></h2><p>LinearSolve.jl automatically selects appropriate algorithms based on matrix properties:</p><ul><li><p><strong>Direct methods</strong> (Cholesky, LU) for small to medium-sized GMRFs</p></li><li><p><strong>Iterative methods</strong> (CG, GMRES) for large sparse GMRFs where direct methods become prohibitively expensive</p></li></ul><p>This matches our general recommendations: Direct solvers combined with selected inversion are highly accurate and stable and should be used whenever possible. However, direct solvers become prohibitively expensive for very large-scale GMRFs, both in terms of compute and memory use. In these regimes, iterative methods may still be a viable option.</p><p>If you have access to both strong parallel computing resources and a Pardiso license, <code>LinearSolve.PardisoJL()</code> may provide the best performance.</p>',5))])}const F=n(h,[["render",b]]);export{T as __pageData,F as default};
