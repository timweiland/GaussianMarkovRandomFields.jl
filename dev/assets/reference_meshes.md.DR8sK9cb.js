import{_ as o,C as r,c as h,o as p,j as s,a as t,aA as n,G as a,w as l}from"./chunks/framework.B28kaWcy.js";const F=JSON.parse('{"title":"Meshes","description":"","frontmatter":{},"headers":[],"relativePath":"reference/meshes.md","filePath":"reference/meshes.md","lastUpdated":null}'),d={name:"reference/meshes.md"},k={class:"jldocstring custom-block",open:""},c={class:"jldocstring custom-block",open:""};function u(g,e,m,f,y,E){const i=r("Badge");return p(),h("div",null,[e[10]||(e[10]=s("h1",{id:"Meshes",tabindex:"-1"},[t("Meshes "),s("a",{class:"header-anchor",href:"#Meshes","aria-label":'Permalink to "Meshes {#Meshes}"'},"​")],-1)),e[11]||(e[11]=s("p",null,"Finite element method discretizations of SPDEs require a mesh. GaussianMarkovRandomFields provides some utility functions to create meshes for common use cases.",-1)),e[12]||(e[12]=s("p",null,[t("For a hands-on example meshing a 2D point cloud, check out the tutorial "),s("a",{href:"/GaussianMarkovRandomFields.jl/dev/tutorials/spatial_modelling_spdes#Spatial-Modelling-with-SPDEs"},"Spatial Modelling with SPDEs"),t(".")],-1)),s("details",k,[s("summary",null,[e[0]||(e[0]=s("a",{id:"GaussianMarkovRandomFields.generate_mesh",href:"#GaussianMarkovRandomFields.generate_mesh"},[s("span",{class:"jlbinding"},"GaussianMarkovRandomFields.generate_mesh")],-1)),e[1]||(e[1]=t()),a(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[4]||(e[4]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">generate_mesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(mp</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">GeometryBasics.MultiPoint</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, buffer_width</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              interior_mesh_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              exterior_mesh_size</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Real</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> interior_mesh_size,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              element_order</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, save_path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate a mesh for a spatial point cloud, with a buffer to counteract boundary effects from the SPDE discretization.</p><p><strong>Input</strong></p><ul><li><p><code>mp</code> – MultiPoint object</p></li><li><p><code>buffer_width</code> – Width of the buffer around the convex hull</p></li><li><p><code>interior_mesh_size</code> – Mesh size inside the convex hull</p></li><li><p><code>exterior_mesh_size</code> – Mesh size outside the convex hull</p></li><li><p><code>element_order</code> – Order of the element basis functions</p></li><li><p><code>save_path</code> – Optional path to save the mesh</p></li></ul><p><strong>Output</strong></p><p>A <code>Ferrite.Grid</code> object</p><p><strong>Algorithm</strong></p><ol><li><p>Create the convex hull of the point cloud via LibGEOS</p></li><li><p>Create the buffer around the convex hull</p></li><li><p>Create a mesh for the buffered polygon using Gmsh</p></li><li><p>Transfer the Gmsh information to Ferrite</p></li></ol>`,8)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[2]||(e[2]=[s("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/77396a9f3c054fbfd3b0ef52966808ace3eb376a/src/mesh/scattered.jl#L187-L215",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1}),e[5]||(e[5]=n('<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">generate_mesh</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(points; element_order</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, save_path</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">nothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Generate a mesh from a list of points using Gmsh.</p><p><strong>Input</strong></p><ul><li><p><code>points</code> – List of points (automatically converted to MultiPoint)</p></li><li><p><code>element_order</code> – Order of the elements</p></li><li><p><code>save_path</code> – Path to save the mesh</p></li></ul><p><strong>Output</strong></p><p>A Ferrite.Grid object</p>',6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[3]||(e[3]=[s("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/77396a9f3c054fbfd3b0ef52966808ace3eb376a/src/mesh/scattered.jl#L254-L268",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})]),s("details",c,[s("summary",null,[e[6]||(e[6]=s("a",{id:"GaussianMarkovRandomFields.create_inflated_rectangle",href:"#GaussianMarkovRandomFields.create_inflated_rectangle"},[s("span",{class:"jlbinding"},"GaussianMarkovRandomFields.create_inflated_rectangle")],-1)),e[7]||(e[7]=t()),a(i,{type:"info",class:"jlObjectType jlFunction",text:"Function"})]),e[9]||(e[9]=n(`<div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">create_inflated_rectangle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(x0, y0, dx, dy, boundary_width, interior_mesh_size,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">exterior_mesh_size </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> interior_mesh_size; element_order </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>Create a triangular FEM discretization of a rectangle with an inflated boundary. Useful for FEM discretizations of SPDEs, where the domain is often artificially inflated to avoid undesirable boundary effects. Mesh has physical groups &quot;Domain&quot;, &quot;Interior&quot;, &quot;Interior boundary&quot; and possibly &quot;Exterior boundary&quot;.</p><p><strong>Arguments</strong></p><ul><li><p><code>x0::Real</code>: x-coordinate of the bottom-left corner of the rectangle</p></li><li><p><code>y0::Real</code>: y-coordinate of the bottom-left corner of the rectangle</p></li><li><p><code>dx::Real</code>: Width of the rectangle</p></li><li><p><code>dy::Real</code>: Height of the rectangle</p></li><li><p><code>boundary_width::Real</code>: Width of the inflated boundary. If 0.0, mesh will not be inflated at all.</p></li><li><p><code>interior_mesh_size::Real</code>: Mesh size in the interior of the rectangle</p></li><li><p><code>exterior_mesh_size::Real</code>: Mesh size in the exterior of the rectangle</p></li><li><p><code>element_order::Int</code>: Order of the FEM elements</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>grid::Ferrite.Grid</code>: the FEM discretization of the rectangle</p></li><li><p><code>boundary_tags::Vector{Int}</code>: the indices of the boundary nodes</p></li></ul>`,6)),a(i,{type:"info",class:"source-link",text:"source"},{default:l(()=>[...e[8]||(e[8]=[s("a",{href:"https://github.com/timweiland/GaussianMarkovRandomFields.jl/blob/77396a9f3c054fbfd3b0ef52966808ace3eb376a/src/mesh/rectangle.jl#L5-L30",target:"_blank",rel:"noreferrer"},"source",-1)])]),_:1})])])}const b=o(d,[["render",u]]);export{F as __pageData,b as default};
