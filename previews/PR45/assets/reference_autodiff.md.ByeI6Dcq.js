import{_ as s,c as a,o as t,aA as e}from"./chunks/framework.jpfjPiBz.js";const c=JSON.parse('{"title":"Automatic Differentiation","description":"","frontmatter":{},"headers":[],"relativePath":"reference/autodiff.md","filePath":"reference/autodiff.md","lastUpdated":null}'),n={name:"reference/autodiff.md"};function l(o,i,r,h,p,k){return t(),a("div",null,[...i[0]||(i[0]=[e(`<h1 id="Automatic-Differentiation" tabindex="-1">Automatic Differentiation <a class="header-anchor" href="#Automatic-Differentiation" aria-label="Permalink to &quot;Automatic Differentiation {#Automatic-Differentiation}&quot;">​</a></h1><p>GaussianMarkovRandomFields.jl provides automatic differentiation (AD) support for parameter estimation, Bayesian inference, and optimization workflows involving GMRFs. Two complementary approaches are available, each with distinct strengths and use cases.</p><h2 id="Zygote-with-custom-chainrules" tabindex="-1">Zygote with custom chainrules <a class="header-anchor" href="#Zygote-with-custom-chainrules" aria-label="Permalink to &quot;Zygote with custom chainrules {#Zygote-with-custom-chainrules}&quot;">​</a></h2><p>The primary AD implementation uses ChainRulesCore.jl to provide efficient reverse-mode automatic differentiation rules. Zygote.jl will automatically load and use these rules. The implementation leverages <a href="https://github.com/timweiland/SelectedInversion.jl" target="_blank" rel="noreferrer">SelectedInversion.jl</a> to compute gradients efficiently without materializing full covariance matrices.</p><h3 id="Supported-Operations" tabindex="-1">Supported Operations <a class="header-anchor" href="#Supported-Operations" aria-label="Permalink to &quot;Supported Operations {#Supported-Operations}&quot;">​</a></h3><p><strong>GMRF Construction</strong>: Differentiation through <code>GMRF(μ, Q, solver_blueprint)</code> and <code>GMRF(μ, Q)</code> constructors, enabling gradients to flow back to mean vectors and precision matrices.</p><p><strong>Log-probability Density</strong>: Efficient differentiation of <code>logpdf(gmrf, z)</code> computations using selected inverses.</p><h3 id="Current-Limitations" tabindex="-1">Current Limitations <a class="header-anchor" href="#Current-Limitations" aria-label="Permalink to &quot;Current Limitations {#Current-Limitations}&quot;">​</a></h3><p><strong>Conditional GMRFs</strong>: Chain rules do not currently support <code>condition_on_observations</code>. For workflows requiring conditional inference with AD, use the LDLFactorizations approach below. Contributions to extend chain rules support to conditional operations are welcome.</p><h3 id="Solver-Compatibility" tabindex="-1">Solver Compatibility <a class="header-anchor" href="#Solver-Compatibility" aria-label="Permalink to &quot;Solver Compatibility {#Solver-Compatibility}&quot;">​</a></h3><p>Chain rules work with any Cholesky-based solver backend:</p><ul><li><p><strong>CHOLMOD</strong> (default): Fast sparse Cholesky via SuiteSparse</p></li><li><p><strong>Pardiso</strong>: Pardiso solver (via package extension)</p></li><li><p><strong>LDLFactorizations</strong>: Pure Julia implementation of a Cholesky solver</p></li></ul><h3 id="Basic-Usage-Example" tabindex="-1">Basic Usage Example <a class="header-anchor" href="#Basic-Usage-Example" aria-label="Permalink to &quot;Basic Usage Example {#Basic-Usage-Example}&quot;">​</a></h3><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> GaussianMarkovRandomFields, Zygote, SparseArrays</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Define precision matrix</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Q </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> spdiagm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">ones</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Sample point for evaluation</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">z </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> randn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Define function to differentiate</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gmrf_from_mean </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> θ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ, Q)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">logpdf_from_mean </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> θ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> logpdf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gmrf_from_mean</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(θ), z)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Differentiate</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">θ_eval </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> zeros</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">gradient</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(logpdf_from_mean, θ_eval)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><h2 id="LDLFactorizations-Approach" tabindex="-1">LDLFactorizations Approach <a class="header-anchor" href="#LDLFactorizations-Approach" aria-label="Permalink to &quot;LDLFactorizations Approach {#LDLFactorizations-Approach}&quot;">​</a></h2><p>The alternative approach uses LDLFactorizations.jl, a plain Julia implementation of sparse Cholesky factorization that supports automatic differentiation through all Julia AD libraries. This &quot;just works&quot;, but you&#39;re limited to LDLFactorizations.jl. This may be fine for moderately sized problems, but CHOLMOD and Pardiso will generally scale much more efficiently.</p><h3 id="When-to-Use" tabindex="-1">When to Use <a class="header-anchor" href="#When-to-Use" aria-label="Permalink to &quot;When to Use {#When-to-Use}&quot;">​</a></h3><ul><li><p><strong>Conditional GMRFs</strong>: (Currently) required for <code>condition_on_observations</code> with AD</p></li><li><p><strong>Forward-mode AD</strong>: Efficient for problems with few parameters</p></li></ul><h3 id="Solver-Configuration" tabindex="-1">Solver Configuration <a class="header-anchor" href="#Solver-Configuration" aria-label="Permalink to &quot;Solver Configuration {#Solver-Configuration}&quot;">​</a></h3><p>Use the <code>:autodiffable</code> solver variant:</p><div class="language-julia vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">julia</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Configure autodiffable solver</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">blueprint </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> CholeskySolverBlueprint{:autodiffable}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gmrf </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> GMRF</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(μ, Q, blueprint)</span></span></code></pre></div><h2 id="Troubleshooting" tabindex="-1">Troubleshooting <a class="header-anchor" href="#Troubleshooting" aria-label="Permalink to &quot;Troubleshooting {#Troubleshooting}&quot;">​</a></h2><p><strong>Error: &quot;Automatic differentiation through logpdf currently only supports Cholesky-based solvers&quot;</strong></p><ul><li>Solution: Ensure your GMRF uses a Cholesky-based solver, not CGSolver or other iterative methods</li></ul><p><strong>Poor performance with chain rules</strong></p><ul><li>Check if you&#39;re accidentally using <code>:autodiffable</code> solver when chain rules would work with default solver</li></ul>`,26)])])}const g=s(n,[["render",l]]);export{c as __pageData,g as default};
