var documenterSearchIndex = {"docs":
[{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"EditURL = \"../literate-tutorials/spatiotemporal_modelling.jl\"","category":"page"},{"location":"tutorials/spatiotemporal_modelling/#Spatiotemporal-Modelling-with-SPDEs","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"","category":"section"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"In this tutorial, we will demonstrate how to perform spatiotemporal Bayesian inference using GMRFs based on a simple toy example.","category":"page"},{"location":"tutorials/spatiotemporal_modelling/#Problem-setup","page":"Spatiotemporal Modelling with SPDEs","title":"Problem setup","text":"","category":"section"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"Our goal is to model how a pollutant (i.e. some chemical) spreads across a river over time. We get (noisy) measurements of the pollutant concentration across the domain at time t = 0, and an additional measurement at some later point in time. To simplify things, we model the river as a 1D domain. Let's set up the problem:","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"x_left, x_right = -1.0, 1.0\nNₓ = 201\nt_start, t_stop = 0.0, 1.0\nNₜ = 101\nts = range(t_start, t_stop, length = Nₜ)\nf_initial = x -> exp(-(x + 0.6)^2 / 0.2^2)\nxs_initial = range(x_left, x_right, length = Nₓ ÷ 2)\nys_initial = f_initial.(xs_initial)\nnoise_precision_initial = 0.1^(-2)\n\nx_later = -0.25\ny_later = 0.55\nnoise_precision_later = 0.01^(-2)\n\nxs_all = [xs_initial; x_later]\nys_all = [ys_initial; y_later]\nN_obs_all = length(ys_all)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/#Using-GMRFs-for-spatiotemporal-modelling","page":"Spatiotemporal Modelling with SPDEs","title":"Using GMRFs for spatiotemporal modelling","text":"","category":"section"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"Fundamentally, we are interested in inferring a spatiotemporal function that models the pollutant concentration over time, which is an infinite-dimensional object. GMRFs, however, are finite-dimensional. This is not a limitation, it just means that we need to discretize space and time to ultimately obtain a discrete approximation to the infinite-dimensional object.","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"We're going to do this as follows:","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"Set up a stochastic PDE (SPDE) that models the spatiotemporal, infinite-dimensional prior (a Gaussian process).\nDiscretize the SPDE in space and time to obtain a GMRF which approximates the Gaussian process.\nCondition the GMRF on the observations to obtain the posterior.","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"Let's start by setting up our discretizations:","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"using GMRFs\nusing Ferrite\n\ngrid = generate_grid(Line, (Nₓ - 1,), Tensors.Vec(x_left), Tensors.Vec(x_right))\ninterpolation = Lagrange{RefLine,1}()\nquadrature_rule = QuadratureRule{RefLine}(2)\ndisc = FEMDiscretization(grid, interpolation, quadrature_rule)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/#A-separable-model","page":"Spatiotemporal Modelling with SPDEs","title":"A separable model","text":"","category":"section"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"Perhaps the simplest spatiotemporal model is a separable one, where the spatial and temporal components are independent. We can model both the spatial and temporal components using Matern processes:","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"spde_space = MaternSPDE{1}(range = 0.2, smoothness = 1, σ² = 0.3)\nspde_time = MaternSPDE{1}(range = 0.5, smoothness = 1)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"Discretize:","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"x_space = discretize(spde_space, disc)\nQ_s = precision_map(x_space)\n\ngrid_time = generate_grid(Line, (Nₜ - 1,), Tensors.Vec(t_start), Tensors.Vec(t_stop))\ndisc_time = FEMDiscretization(grid_time, interpolation, quadrature_rule)\nx_time = discretize(spde_time, disc_time)\nQ_t = precision_map(x_time)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"Create the separable spatiotemporal model:","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"x_st_kron = kronecker_product_spatiotemporal_model(Q_t, Q_s, disc)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"Great! Now let's condition on the observations. To do this, we construct a \"spatial\" observation matrix and transform it into a \"spatiotemporal\" observation matrix:","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"A_initial = evaluation_matrix(disc, [Tensors.Vec(x) for x in xs_initial])\nt_initial_idx = 1 # Observe at first time point\nA_initial = spatial_to_spatiotemporal(A_initial, t_initial_idx, Nₜ)\nA_later = evaluation_matrix(disc, [Tensors.Vec(x_later)])\nt_later_idx = 2 * Nₜ ÷ 3\nA_later = spatial_to_spatiotemporal(A_later, t_later_idx, Nₜ)\n\nA_all = [A_initial; A_later]\n\nusing LinearAlgebra, SparseArrays\nQ_noise = sparse(I, N_obs_all, N_obs_all) * noise_precision_initial\nQ_noise[end, end] = noise_precision_later","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"Condition on the observations:","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"x_st_kron_posterior = condition_on_observations(x_st_kron, A_all, Q_noise, ys_all)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"Let's look at the dynamics of this posterior.","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"using CairoMakie\nCairoMakie.activate!()\nplot(x_st_kron_posterior, t_initial_idx)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"plot(x_st_kron_posterior, Nₜ ÷ 3)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"plot(x_st_kron_posterior, 2 * Nₜ ÷ 3)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"plot(x_st_kron_posterior, Nₜ)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"We see that the effect of our observations effectively just \"dies off\" over time. And generally in spatiotemporal statistics, this is a fair assumption: The further away in time we are from an observation, the less it should influence our predictions.","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"But in our case, we know a bit more about the phenomenon at hand. This is a river, and we know that it flows in a certain direction, and we probably also roughly know the flow speed. We should embed this information into our prior to get a more useful posterior!","category":"page"},{"location":"tutorials/spatiotemporal_modelling/#Advection-diffusion-priors","page":"Spatiotemporal Modelling with SPDEs","title":"Advection-diffusion priors","text":"","category":"section"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"We can achieve this through a non-separable model that encodes these dynamics. Concretely, we are going to consider an advection-diffusion SPDE as presented in [2].","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"adv_diff_spde = AdvectionDiffusionSPDE{1}(\n    γ = [-0.6],\n    H = 0.1 * sparse(I, (1, 1)),\n    τ = 0.1,\n    α = 2 // 1,\n    spatial_spde = spde_space,\n    initial_spde = spde_space,\n)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"To discretize this SPDE, we only need a FEM discretization of space. For time, we simply specify the discrete time points which are then used internally for an implicit Euler scheme.","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"x_adv_diff = discretize(adv_diff_spde, disc, ts)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"Condition on the initial observations:","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"x_adv_diff_posterior = condition_on_observations(x_adv_diff, A_all, Q_noise, ys_all)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"Let's look at the dynamics of this posterior.","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"plot(x_adv_diff_posterior, t_initial_idx)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"plot(x_adv_diff_posterior, Nₜ ÷ 3)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"plot(x_adv_diff_posterior, 2 * Nₜ ÷ 3)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"plot(x_adv_diff_posterior, Nₜ)","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"This looks much more reasonable! We see that the pollutant is transported downstream over time, and the observations at the later time point are consistent with this.","category":"page"},{"location":"tutorials/spatiotemporal_modelling/#Conclusion","page":"Spatiotemporal Modelling with SPDEs","title":"Conclusion","text":"","category":"section"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"We have seen how to model spatiotemporal phenomena using GMRFs. We started with a simple separable model and then moved on to a more complex advection-diffusion model. The latter model was able to capture the dynamics of the river and the pollutant transport much better.","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"As mentioned initially, this was a simple toy example. But the underlying principles are the same for more complex problems. In particular, all of the above should work the same for arbitrary spatial meshes, as demonstrated e.g. in the tutorial Spatial Modelling with SPDEs.","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"","category":"page"},{"location":"tutorials/spatiotemporal_modelling/","page":"Spatiotemporal Modelling with SPDEs","title":"Spatiotemporal Modelling with SPDEs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"EditURL = \"../literate-tutorials/boundary_conditions.jl\"","category":"page"},{"location":"tutorials/boundary_conditions/#Boundary-Conditions-for-SPDEs","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"","category":"section"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"In previous tutorials, we saw that we can approximate stochastic processes with GMRFs by discretizing stochastic partial differential equations (SPDEs). Such discretizations always involve boundary conditions, which specify the behavior of the process at the boundary of the domain. In the context of the finite element method, the simplest boundary condition is a homogeneous von Neumann boundary condition, which specifies that the derivative of the process normal to the boundary is zero. This approach is also used in the seminal work by Lindgren et al. [1].","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"Yet, in practice, this behavior is often not desirable. To circumvent boundary effects, people often artificially inflate the domain by adding a buffer zone around the data.","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"But what if we know the behavior of the process at the boundary, and it's not \"the normal derivative is zero\"? Fortunately, GMRFs.jl interfaces rather smoothly with Ferrite.jl, which we can use to specify more complex boundary conditions. Let's see how this works.","category":"page"},{"location":"tutorials/boundary_conditions/#Spatial-example:-Matern-SPDE","page":"Boundary Conditions for SPDEs","title":"Spatial example: Matern SPDE","text":"","category":"section"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"We start by specifying a mesh over the interval [-1, 1].","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"using GMRFs, Ferrite\ngrid = generate_grid(Line, (50,))\ninterpolation = Lagrange{RefLine,1}()\nquadrature_rule = QuadratureRule{RefLine}(2)","category":"page"},{"location":"tutorials/boundary_conditions/#Dirichlet-boundary","page":"Boundary Conditions for SPDEs","title":"Dirichlet boundary","text":"","category":"section"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"Let us now use Ferrite to define a homogeneous Dirichlet boundary condition, which specifies that the process is zero at the boundary.","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"function get_dirichlet_constraint(grid::Ferrite.Grid{1})\n    boundary = getfacetset(grid, \"left\") ∪ getfacetset(grid, \"right\")\n\n    return Dirichlet(:u, boundary, x -> (x[1] ≈ -1.0) ? 0.0 : (x[1] ≈ 1.0) ? 0.0 : 0.0)\nend\n\ndbc = get_dirichlet_constraint(grid)","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"GMRFs.jl supports such boundary conditions in a \"soft\" way. This means that we enforce the boundary conditions up to noise of a certain, user-specified magnitude. This ensures that the resulting GMRF has full rank. If you don't care much for probabilistic boundary conditions, you can just set the noise to a sufficiently small value.","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"bcs = [(dbc, 1e-4)] # 1e-4 is the noise in terms of the standard deviation","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"We can now create a FEM discretization with the specified boundary conditions.","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"disc = FEMDiscretization(grid, interpolation, quadrature_rule, [(:u, nothing)], bcs)","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"Let's now define some Matern SPDE and discretize it.","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"matern_spde = MaternSPDE{1}(range = 0.5, smoothness = 1, σ² = 0.3)\nx = discretize(matern_spde, disc)","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"Verify for yourself that the boundary value is zero for all samples, and that the variance vanishes at the boundary:","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"using CairoMakie\nCairoMakie.activate!()\nplot(x, disc)","category":"page"},{"location":"tutorials/boundary_conditions/#Periodic-boundary","page":"Boundary Conditions for SPDEs","title":"Periodic boundary","text":"","category":"section"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"We can also define a periodic boundary condition in terms of an affine constraint:","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"function get_periodic_constraint(grid::Ferrite.Grid{1})\n    cellidx_left, dofidx_left = collect(grid.facetsets[\"left\"])[1]\n    cellidx_right, dofidx_right = collect(grid.facetsets[\"right\"])[1]\n\n    temp_dh = DofHandler(grid)\n    add!(temp_dh, :u, Lagrange{RefLine,1}())\n    close!(temp_dh)\n    cc = CellCache(temp_dh)\n    get_dof(cell_idx, dof_idx) = (reinit!(cc, cell_idx); celldofs(cc)[dof_idx])\n    dof_left = get_dof(cellidx_left, dofidx_left)\n    dof_right = get_dof(cellidx_right, dofidx_right)\n\n    return AffineConstraint(dof_left, [dof_right => 1.0], 0.0)\nend\n\npbc = get_periodic_constraint(grid)","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"The rest of the procedure is analogous to the Dirichlet case:","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"bcs = [(pbc, 1e-4)]\ndisc_periodic =\n    FEMDiscretization(grid, interpolation, quadrature_rule, [(:u, nothing)], bcs)\nx_periodic = discretize(matern_spde, disc_periodic)","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"Verify for yourself that the values at the left and right boundary match for all samples:","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"plot(x_periodic, disc)","category":"page"},{"location":"tutorials/boundary_conditions/#Spatiotemporal-example:-Advection-Diffusion-SPDE","page":"Boundary Conditions for SPDEs","title":"Spatiotemporal example: Advection-Diffusion SPDE","text":"","category":"section"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"This works just as well in the spatiotemporal case. Let's reuse our previous discretization for a 1D advection-diffusion SPDE:","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"using LinearAlgebra, SparseArrays\nspde = AdvectionDiffusionSPDE{1}(\n    γ = [-0.6],\n    H = 0.1 * sparse(I, (1, 1)),\n    τ = 0.1,\n    α = 2 // 1,\n    spatial_spde = matern_spde,\n    initial_spde = matern_spde,\n)\nts = 0:0.05:1\nN_t = length(ts)\nx_adv_diff_dirichlet = discretize(spde, disc, ts)\nx_adv_diff_periodic = discretize(spde, disc_periodic, ts)","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"To make things clearer, we are going to condition these GMRFs on a Gaussian initial condition to see how it propagates over time.","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"xs_ic = -0.99:0.01:0.99\nys_ic = exp.(-xs_ic .^ 2 / 0.2^2)\nA_ic = evaluation_matrix(disc, [Tensors.Vec(x) for x in xs_ic])\nA_ic = spatial_to_spatiotemporal(A_ic, 1, N_t)\n\nx_adv_diff_dirichlet = condition_on_observations(x_adv_diff_dirichlet, A_ic, 1e8, ys_ic)\nx_adv_diff_periodic = condition_on_observations(x_adv_diff_periodic, A_ic, 1e8, ys_ic)","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"First, check the initial observations:","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"plot(x_adv_diff_dirichlet, 1)","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"Now, let's see how the process evolves over time:","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"plot(x_adv_diff_dirichlet, N_t ÷ 2)","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"plot(x_adv_diff_dirichlet, N_t)","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"Compare to this to the periodic case:","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"plot(x_adv_diff_periodic, N_t ÷ 2)","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"plot(x_adv_diff_periodic, N_t)","category":"page"},{"location":"tutorials/boundary_conditions/#Conclusion","page":"Boundary Conditions for SPDEs","title":"Conclusion","text":"","category":"section"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"We have seen how to specify more complex boundary conditions for GMRFs. All it takes is to construct the boundary conditions in Ferrite and add some noise.","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"For the sake of simplicity, this tutorial considered discretizations of a one-dimensional interval, but of course the same principles apply to higher dimensions and more complex geometries.","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"","category":"page"},{"location":"tutorials/boundary_conditions/","page":"Boundary Conditions for SPDEs","title":"Boundary Conditions for SPDEs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/preconditioners/#Preconditioners","page":"Preconditioners","title":"Preconditioners","text":"","category":"section"},{"location":"reference/preconditioners/","page":"Preconditioners","title":"Preconditioners","text":"AbstractPreconditioner\nBlockJacobiPreconditioner\nFullCholeskyPreconditioner\ntemporal_block_gauss_seidel\nTridiagonalBlockGaussSeidelPreconditioner\nTridiagSymmetricBlockGaussSeidelPreconditioner","category":"page"},{"location":"reference/preconditioners/#GMRFs.AbstractPreconditioner","page":"Preconditioners","title":"GMRFs.AbstractPreconditioner","text":"AbstractPreconditioner\n\nAbstract type for preconditioners. Should implement the following methods:\n\nldiv!(y, P::AbstractPreconditioner, x::AbstractVector)\nldiv!(P::AbstractPreconditioner, x::AbstractVector)\n\\(P::AbstractPreconditioner, x::AbstractVector)\nsize(P::AbstractPreconditioner)\n\n\n\n\n\n","category":"type"},{"location":"reference/preconditioners/#GMRFs.BlockJacobiPreconditioner","page":"Preconditioners","title":"GMRFs.BlockJacobiPreconditioner","text":"BlockJacobiPreconditioner\n\nA preconditioner that uses a block Jacobi preconditioner, i.e. P = diag(A₁, A₂, ...), where each Aᵢ is a preconditioner for a block of the matrix.\n\n\n\n\n\n","category":"type"},{"location":"reference/preconditioners/#GMRFs.FullCholeskyPreconditioner","page":"Preconditioners","title":"GMRFs.FullCholeskyPreconditioner","text":"FullCholeskyPreconditioner\n\nA preconditioner that uses a full Cholesky factorization of the matrix, i.e. P = A, so P⁻¹ = A⁻¹. Does not make sense to use on its own, but can be used as a building block for more complex preconditioners.\n\n\n\n\n\n","category":"type"},{"location":"reference/preconditioners/#GMRFs.temporal_block_gauss_seidel","page":"Preconditioners","title":"GMRFs.temporal_block_gauss_seidel","text":"temporal_block_gauss_seidel(A, block_size)\n\nConstruct a temporal block Gauss-Seidel preconditioner for a spatiotemporal matrix with constant spatial mesh size (and thus constant spatial block size).\n\n\n\n\n\n","category":"function"},{"location":"reference/preconditioners/#GMRFs.TridiagonalBlockGaussSeidelPreconditioner","page":"Preconditioners","title":"GMRFs.TridiagonalBlockGaussSeidelPreconditioner","text":"TridiagonalBlockGaussSeidelPreconditioner{T}(D_blocks, L_blocks)\nTridiagonalBlockGaussSeidelPreconditioner{T}(D⁻¹_blocks, L_blocks)\n\nBlock Gauss-Seidel preconditioner for block tridiagonal matrices. For a matrix given by\n\nA = beginbmatrix\nD₁  L₁ᵀ  0  cdots  0 \nL₁  D₂  L₂ᵀ  0  cdots \n0  L₂  D₃  L₃ᵀ  cdots \nvdots  vdots  vdots  ddots  vdots \n0  cdots  0  Lₙ₁  Lₙ\nendbmatrix\n\nthis preconditioner is given by\n\nP = beginbmatrix\nD₁  0  cdots  0 \nL₁  D₂  0  cdots \n0  L₂  D₃  cdots \nvdots  vdots  vdots  ddots  vdots \n0  cdots  0  Lₙ₁  Dₙ\nendbmatrix\n\nSolving linear systems with the preconditioner is made efficient through block forward / backward substitution. The diagonal blocks must be inverted. As such, they may be specified\n\ndirectly as matrices: in this case they will be transformed into FullCholeskyPreconditioners.\nin terms of their invertible preconditioners\n\n\n\n\n\n","category":"type"},{"location":"reference/preconditioners/#GMRFs.TridiagSymmetricBlockGaussSeidelPreconditioner","page":"Preconditioners","title":"GMRFs.TridiagSymmetricBlockGaussSeidelPreconditioner","text":"TridiagSymmetricBlockGaussSeidelPreconditioner{T}(D_blocks, L_blocks)\nTridiagSymmetricBlockGaussSeidelPreconditioner{T}(D⁻¹_blocks, L_blocks)\n\nSymmetric Block Gauss-Seidel preconditioner for symmetric block tridiagonal matrices. For a symmetric matrix given by the block decomposition A = L + D + Lᵀ, where L is strictly lower triangular and D is diagonal, this preconditioner is given by P = (L + D) D⁻¹ (L + D)ᵀ ≈ A.\n\nSolving linear systems with the preconditioner is made efficient through block forward / backward substitution. The diagonal blocks must be inverted. As such, they may be specified\n\ndirectly as matrices: in this case they will be transformed into FullCholeskyPreconditioners.\nin terms of their invertible preconditioners\n\n\n\n\n\n","category":"type"},{"location":"reference/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"reference/plotting/","page":"Plotting","title":"Plotting","text":"GMRFs.jl offers recipes to make plotting spatial and spatiotemporal GMRFs effortless. These recipes are contained in a package extension which gets loaded automatically when using Makie (or rather: one of its backends).","category":"page"},{"location":"reference/plotting/","page":"Plotting","title":"Plotting","text":"All of the following methods may also be called more simply by calling plot or plot! with appropriate arguments.","category":"page"},{"location":"reference/plotting/","page":"Plotting","title":"Plotting","text":"note: Note\nCurrently, we only provide recipes for 1D spatial and spatiotemporal GMRFs. This may change soon (feel free to open a PR!) Until then, note that any 2D or 3D FEM-based GMRF may be plotted indirectly through Ferrite's support of VTK files, which may then subsequently be opened e.g. in ParaView for visualization. See Spatial Modelling with SPDEs for an example.","category":"page"},{"location":"reference/plotting/","page":"Plotting","title":"Plotting","text":"gmrf_fem_1d_plot\ngmrf_fem_1d_spatiotemporal_plot","category":"page"},{"location":"reference/plotting/#GMRFs.gmrf_fem_1d_plot","page":"Plotting","title":"GMRFs.gmrf_fem_1d_plot","text":"gmrf_fem_1d_plot(gmrf::AbstractGMRF, disc::FEMDiscretization{1})\n\nPlot the GMRF gmrf based on the 1D FEM discretization disc.\n\nArguments\n\ngmrf::AbstractGMRF: The GMRF to plot.\ndisc::FEMDiscretization{1}: The FEM discretization.\n\nKeyword arguments\n\nwith_std::Bool=true: Whether to plot the confidence bands.\nN_samples::Int=3: The number of samples to plot.\nrng::AbstractRNG=Random.default_rng(): The random number generator.\nfield::Symbol=:default: The field to plot.\nmean_color: The color of the mean line.\nconf_band_color: The color of the confidence bands.\nsample_color: The color of the samples.\n\n\n\n\n\n","category":"function"},{"location":"reference/plotting/#GMRFs.gmrf_fem_1d_spatiotemporal_plot","page":"Plotting","title":"GMRFs.gmrf_fem_1d_spatiotemporal_plot","text":"gmrf_fem_1d_spatiotemporal_plot(\n    gmrf::Union{\n        ConstantMeshSTGMRF{1}, LinearConditionalGMRF{<:ConstantMeshSTGMRF{1}}\n        },\n    t_idx::Int\n)\n\nPlot the 1D spatiotemporal GMRF gmrf at time index t_idx.\n\nArguments\n\ngmrf: The GMRF to plot.\nt_idx::Int: The time index.\n\nKeyword arguments\n\nwith_std::Bool=true: Whether to plot the confidence bands.\nN_samples::Int=3: The number of samples to plot.\nrng::AbstractRNG=Random.default_rng(): The random number generator.\nfield::Symbol=:default: The field to plot.\nmean_color: The color of the mean line.\nconf_band_color: The color of the confidence bands.\nsample_color: The color of the samples.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"EditURL = \"../literate-tutorials/autoregressive_models.jl\"","category":"page"},{"location":"tutorials/autoregressive_models/#Building-autoregressive-models","page":"Building autoregressive models","title":"Building autoregressive models","text":"","category":"section"},{"location":"tutorials/autoregressive_models/#Introduction","page":"Building autoregressive models","title":"Introduction","text":"","category":"section"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"In the following, we will construct a first-order auto-regressive model with Gaussian errors. Mathematically, this is expressed by","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"x_0 sim mathcalN(mu_0 Lambda_0) \nx_t+1 = phi x_t + varepsilon_t quad varepsilon sim mathcalN(0 Lambda)","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"The latter equation is equivalent to the likelihood","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"x_t+1 mid x_t sim mathcalN(phi x_t Lambda)","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"Under this model, the joint distribution over x_1 dots x_N (where N is the number of steps) is Gaussian:","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"beginpmatrix x_0  x_1  x_2  vdots  x_N-1  x_N endpmatrix\nsim mathcalNleft(\nbeginpmatrix mu_0  phi mu_0  phi^2 mu_0  vdots \nphi^N-1 mu_0  phi^N mu_0 endpmatrix\nbeginpmatrix Lambda_0  -phi      \n-phi  Lambda + phi^2  -phi     \n      \n  ddots  ddots  ddots   \n      \n    -phi  Lambda + phi^2  -phi \n     -phi  Lambda\nendpmatrix^-1\nright)","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"The first-order Markov structure of the model results in a tridiagonal precision matrix. Thus, if we work with this Gaussian distribution in precision form (also commonly called information form), we gain tremendous computational benefits. By contrast, the covariance matrix of this Gaussian is fully dense.","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"More generally, this package deals with any sparse precision matrix, not just tridiagonal ones. Such Gaussians with sparse precision matrices are called GMRFs (short for Gaussian Markov Random Fields).","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"In the following, we construct a GMRF for the above first-order autoregressive model first manually by computing the mean and precision, and then automatically by simply specifying the parameters of the model.","category":"page"},{"location":"tutorials/autoregressive_models/#Building-an-AR(1)-model","page":"Building autoregressive models","title":"Building an AR(1) model","text":"","category":"section"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"We begin by loading GMRFs and LinearAlgebra.","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"using GMRFs, LinearAlgebra","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"We define a discretization of the real interval 0 1, and specify some example parameters for the AR(1) model:","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"xs = 0:0.01:1\nN = length(xs)\nϕ = 0.995\nΛ₀ = 1e6\nΛ = 1e3","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"Now we compute the mean and the precision matrix of the joint distribution. We explicitly declare the precision matrix as a symmetric tridiagonal matrix, which unlocks highly efficient linear algebra routines for the underlying computations.","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"μ = [ϕ^(i - 1) for i in eachindex(xs)]\ndiag = [[Λ₀]; repeat([Λ + ϕ^2], N - 2); [Λ]]\noff_diag = repeat([-ϕ], N - 1)\nQ = SymTridiagonal(diag, off_diag)\nx = GMRF(μ, Q)","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"A GMRF is a multivariate Gaussian, and it's compatible with Distributions.jl. We can get its mean, marginal standard deviation, and draw samples as follows:","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"using Plots, Distributions\nplot(xs, mean(x), ribbon = 1.96 * std(x), label = \"Mean + std\")\nfor i = 1:3\n    plot!(xs, rand(x), fillalpha = 0.3, linestyle = :dash, label = \"Sample\")\nend\nplot!()","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"Great! Looks like an AR(1) model.","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"But what can you do with this? Well, for example you can use it as a prior for Bayesian inference. If we have a likelihood of the form","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"y mid x sim mathcalN(Ax Lambda_textobs^-1)","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"then the posterior conditioned on these observations is again a GMRF, the moments of which we can compute in closed form. In terms of code, we achieve this through condition_on_observations. Let's condition our model on the observations x_26 = 085 and x_76 = 071:","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"using SparseArrays\nA = spzeros(2, N)\nA[1, 26] = 1.0\nA[2, 76] = 1.0\ny = [0.85, 0.71]\nΛ_obs = 1e6\nx_cond = condition_on_observations(x, A, Λ_obs, y)","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"Indeed, our model now conforms to these observations:","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"plot(xs, mean(x_cond), ribbon = 1.96 * std(x_cond), label = \"Mean + std\")\nfor i = 1:3\n    plot!(xs, rand(x_cond), fillalpha = 0.3, linestyle = :dash, label = \"Sample\")\nend\nplot!()","category":"page"},{"location":"tutorials/autoregressive_models/#Beyond-first-order-models:-CARs","page":"Building autoregressive models","title":"Beyond first-order models: CARs","text":"","category":"section"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"You may have noticed that the AR(1) model above produces very rough samples. This may or may not be desirable, depending on the application. If we do want smoother samples, we can increase the order of the model. This adds off-diagonals to the precision matrix and thus reduces its sparsity, so computations become a bit more expensive. But it may be worth the overhead.","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"One model class to produce autoregressive models with flexible conditional dependencies and sparse precision matrices is that of conditional autoregressive models (CARs). Such models are constructed based on a graph representation of the underlying data, where there is an edge between two nodes if they are conditionally dependent.","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"Let us construct an adjacency matrix that relates nodes not only to their immediate neighbors, but also to the neighbors' neighbors (a second-order model).","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"W = spzeros(N, N)\nfor i = 1:N\n    for k in [-2, -1, 1, 2]\n        j = i + k\n        if 1 <= j <= N\n            W[i, j] = 1.0 / abs(k)\n        end\n    end\nend","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"Now that we have the adjacency matrix, we can use a GMRFs.jl utility function to generate a CAR model from it, which internally constructs a slight variation of the graph Laplacian to form the precision matrix.","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"x_car = generate_car_model(W, 0.9; μ = μ, σ = 0.001)","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"Let's take our CAR for a test drive:","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"plot(xs, mean(x_car), ribbon = 1.96 * std(x_car), label = \"Mean + std\")\nfor i = 1:3\n    plot!(xs, rand(x_car), fillalpha = 0.3, linestyle = :dash, label = \"Sample\")\nend\nplot!()","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"Let's see how this model fits data. We take the same observations as for the AR(1) model, but also add an observation for the starting point to reduce the uncertainty there.","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"A = spzeros(3, N)\nA[1, 1] = 1.0\nA[2, 26] = 1.0\nA[3, 76] = 1.0\ny = [1.0, 0.85, 0.71]\nΛ_obs = 1e6\nx_car_cond = condition_on_observations(x_car, A, Λ_obs, y)\nplot(xs, mean(x_car_cond), ribbon = 1.96 * std(x_car_cond), label = \"Mean + std\")\nfor i = 1:3\n    plot!(xs, rand(x_car_cond), fillalpha = 0.3, linestyle = :dash, label = \"Sample\")\nend\nplot!()","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"As expected, the interpolation of this model is less abrupt and spiky than for the AR(1) model.","category":"page"},{"location":"tutorials/autoregressive_models/#Outlook","page":"Building autoregressive models","title":"Outlook","text":"","category":"section"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"CAR models are quite flexible. Particularly for spatial data however, it is more common to model continuously through a Gaussian process. Fortunately, it turns out that popular Gaussian processes can be approximated quite nicely through GMRFs, allowing us to do the modelling in terms of a GP and the computations in terms of a GMRF. To learn more about this approach, check the tutorial on Spatial Modelling with SPDEs.","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"","category":"page"},{"location":"tutorials/autoregressive_models/","page":"Building autoregressive models","title":"Building autoregressive models","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/#Tutorials","page":"Overview","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Overview","title":"Overview","text":"Pages = [\n    \"autoregressive_models.md\",\n    \"spatial_modelling_spdes.md\",\n    \"boundary_conditions.md\"\n]","category":"page"},{"location":"reference/linear_maps/#Linear-Maps","page":"Linear maps","title":"Linear Maps","text":"","category":"section"},{"location":"reference/linear_maps/","page":"Linear maps","title":"Linear maps","text":"The construction of GMRFs involves various kinds of structured matrices. These structures may be leveraged in downstream computations to save compute and memory. But to make this possible, we need to actually keep track of these structures -  which we achieve through diverse subtypes of LinearMap.","category":"page"},{"location":"reference/linear_maps/","page":"Linear maps","title":"Linear maps","text":"SymmetricBlockTridiagonalMap\nSSMBidiagonalMap\nOuterProductMap\nLinearMapWithSqrt\nCholeskySqrt\nZeroMap\nADJacobianMap\nADJacobianAdjointMap","category":"page"},{"location":"reference/linear_maps/#GMRFs.SymmetricBlockTridiagonalMap","page":"Linear maps","title":"GMRFs.SymmetricBlockTridiagonalMap","text":"SymmetricBlockTridiagonalMap(\n    diagonal_blocks::Tuple{LinearMap{T},Vararg{LinearMap{T},ND}},\n    off_diagonal_blocks::Tuple{LinearMap{T},Vararg{LinearMap{T},NOD}},\n)\n\nA linear map representing a symmetric block tridiagonal matrix with diagonal blocks diagonal_blocks and lower off-diagonal blocks off_diagonal_blocks.\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_maps/#GMRFs.SSMBidiagonalMap","page":"Linear maps","title":"GMRFs.SSMBidiagonalMap","text":"SSMBidiagonalMap{T}(\n    A::LinearMap{T},\n    B::LinearMap{T},\n    C::LinearMap{T},\n    N_t::Int,\n)\n\nRepresents the block-bidiagonal map given by the (Nt) x (Nt - 1) sized block structure:\n\nbeginbmatrix\nA  0  cdots  0 \nB  C  cdots  0 \n0  B  C  0 \nvdots  vdots  ddots  vdots \n0  0  cdots  B\nendbmatrix\n\nwhich occurs as a square root in the discretization of GMRF-based state-space models. N_t is the total number of blocks along the rows.\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_maps/#GMRFs.OuterProductMap","page":"Linear maps","title":"GMRFs.OuterProductMap","text":"OuterProductMap{T}(\n    A::LinearMap{T},\n    Q::LinearMap{T},\n)\n\nRepresents the outer product A' Q A, without actually forming it in memory.\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_maps/#GMRFs.LinearMapWithSqrt","page":"Linear maps","title":"GMRFs.LinearMapWithSqrt","text":"LinearMapWithSqrt{T}(\n    A::LinearMap{T},\n    A_sqrt::LinearMap{T},\n)\n\nA symmetric positive definite linear map A with known square root A_sqrt, i.e. A = A_sqrt * A_sqrt'. Behaves just like A, but taking the square root directly returns A_sqrt.\n\nArguments\n\nA::LinearMap{T}: The linear map A.\nA_sqrt::LinearMap{T}: The square root of A.\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_maps/#GMRFs.CholeskySqrt","page":"Linear maps","title":"GMRFs.CholeskySqrt","text":"CholeskySqrt{T}(cho::Union{Cholesky{T},SparseArrays.CHOLMOD.Factor{T}})\n\nA linear map representing the square root obtained from a Cholesky factorization, i.e. for A = L * L', this map represents L.\n\nArguments\n\ncho::Union{Cholesky{T},SparseArrays.CHOLMOD.Factor{T}}:   The Cholesky factorization of a symmetric positive definite matrix.\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_maps/#GMRFs.ZeroMap","page":"Linear maps","title":"GMRFs.ZeroMap","text":"ZeroMap{T}(N::Int, M::Int)\n\nA linear map that maps all vectors to the zero vector.\n\nArguments\n\nN::Int: Output dimension\nM::Int: Input dimension\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_maps/#GMRFs.ADJacobianMap","page":"Linear maps","title":"GMRFs.ADJacobianMap","text":"ADJacobianMap(f::Function, x₀::AbstractVector{T}, N_outputs::Int)\n\nA linear map representing the Jacobian of f at x₀. Uses forward-mode AD in a matrix-free way, i.e. we do not actually store the Jacobian in memory and only compute JVPs.\n\nRequires ForwardDiff.jl!\n\nArguments\n\nf::Function: Function to differentiate.\nx₀::AbstractVector{T}: Input vector at which to evaluate the Jacobian.\nN_outputs::Int: Output dimension of f.\n\n\n\n\n\n","category":"type"},{"location":"reference/linear_maps/#GMRFs.ADJacobianAdjointMap","page":"Linear maps","title":"GMRFs.ADJacobianAdjointMap","text":"ADJacobianAdjointMap{T}(f::Function, x₀::AbstractVector{T}, N_outputs::Int)\n\nA linear map representing the adjoint of the Jacobian of f at x₀. Uses reverse-mode AD in a matrix-free way, i.e. we do not actually store the Jacobian in memory and only compute VJPs.\n\nRequires Zygote.jl!\n\nArguments\n\nf::Function: Function to differentiate.\nx₀::AbstractVector{T}: Input vector at which to evaluate the Jacobian.\nN_outputs::Int: Output dimension of f.\n\n\n\n\n\n","category":"type"},{"location":"dev-docs/spdes/#SPDEs","page":"SPDEs","title":"SPDEs","text":"","category":"section"},{"location":"dev-docs/spdes/","page":"SPDEs","title":"SPDEs","text":"GMRFs.matern_mean_precision","category":"page"},{"location":"dev-docs/spdes/#GMRFs.matern_mean_precision","page":"SPDEs","title":"GMRFs.matern_mean_precision","text":"matern_precision(C_inv::AbstractMatrix, K::AbstractMatrix, α::Integer)\n\nCompute the precision matrix of a GMRF discretization of a Matérn SPDE. Implements the recursion described in [1].\n\nArguments\n\nC_inv::AbstractMatrix: The inverse of the (possibly lumped) mass matrix.\nK::AbstractMatrix: The stiffness matrix.\nα::Integer: The parameter α = ν + d/2 of the Matérn SPDE.\n\n\n\n\n\n","category":"function"},{"location":"reference/#API-Reference-overview","page":"Overview","title":"API Reference overview","text":"","category":"section"},{"location":"reference/","page":"Overview","title":"Overview","text":"Pages = [\n    \"gmrfs.md\",\n    \"spdes.md\",\n    \"discretizations.md\",\n    \"meshes.md\",\n    \"plotting.md\",\n    \"solvers.md\",\n    \"autoregressive.md\",\n    \"linear_maps.md\",\n    \"gn_optim.md\",\n    \"preconditioners.md\",\n]","category":"page"},{"location":"reference/autoregressive/#Autoregressive-Models","page":"Autoregressive Models","title":"Autoregressive Models","text":"","category":"section"},{"location":"reference/autoregressive/","page":"Autoregressive Models","title":"Autoregressive Models","text":"For a hands-on example, check out the tutorial Building autoregressive models.","category":"page"},{"location":"reference/autoregressive/","page":"Autoregressive Models","title":"Autoregressive Models","text":"generate_car_model","category":"page"},{"location":"reference/autoregressive/#GMRFs.generate_car_model","page":"Autoregressive Models","title":"GMRFs.generate_car_model","text":"generate_car_model(W::SparseMatrixCSC, ρ::Real; σ=1.0, μ=nothing)\n\nGenerate a conditional autoregressive model (CAR) in GMRF form from an adjacency matrix.\n\nInput\n\nW – Adjacency / weight matrix. Specifies the conditional dependencies        between variables\nρ – Weighting factor of the inter-node dependencies. Fulfills 0 < ρ < 1.\nσ – Variance scaling factor (i.e. output scale)\nμ – Mean vector\n\nOutput\n\nA GMRF with the corresponding mean and precision.\n\nAlgorithm\n\nThe CAR is constructed using a variant of the graph Laplacian, i.e.\n\nQ = sigma^-1 cdot (W 1 - ρ cdot W)\n\n\n\n\n\n","category":"function"},{"location":"reference/spdes/#SPDEs","page":"SPDEs","title":"SPDEs","text":"","category":"section"},{"location":"reference/spdes/","page":"SPDEs","title":"SPDEs","text":"SPDE\nMaternSPDE\nAdvectionDiffusionSPDE","category":"page"},{"location":"reference/spdes/#GMRFs.SPDE","page":"SPDEs","title":"GMRFs.SPDE","text":"SPDE\n\nAn abstract type for a stochastic partial differential equation (SPDE).\n\n\n\n\n\n","category":"type"},{"location":"reference/spdes/#GMRFs.MaternSPDE","page":"SPDEs","title":"GMRFs.MaternSPDE","text":"MaternSPDE{D}(κ::Real, ν::Union{Integer, Rational}) where D\n\nThe Whittle-Matérn SPDE is given by\n\n(κ^2 - Δ)^fracα2 u(x) = 𝒲(x) quad left( x in mathbbR^d\nα = ν + fracd2 right)\n\nwhere Δ is the Laplacian operator, κ  0, ν  0.\n\nThe stationary solutions to this SPDE are Matérn processes.\n\n\n\n\n\n","category":"type"},{"location":"reference/spdes/#GMRFs.AdvectionDiffusionSPDE","page":"SPDEs","title":"GMRFs.AdvectionDiffusionSPDE","text":"AdvectionDiffusionSPDE{D}(κ::Real, α::Rational, H::AbstractMatrix,\nγ::AbstractVector, c::Real, τ::Real) where {D}\n\nSpatiotemporal advection-diffusion SPDE as proposed in [2]:\n\nleft fract + frac1c left( κ^2 -   H  right)^alpha\n+ frac1c γ   right X(t s) = fracτsqrtc Z(t s)\n\nwhere Z(t, s) is spatiotemporal noise which may be colored.\n\n\n\n\n\n","category":"type"},{"location":"reference/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"Fundamentally, all interesting quantities of GMRFs (samples, marginal variances, posterior means, ...) must be computed through sparse linear algebra. GMRFs.jl provides a number of so-called solvers which perform the underlying computations in different ways and with different trade-offs. Our goal is to provide sane defaults that \"just work\" for most users, while still allowing power users to customize the behavior of the solvers. Read further to learn about the available solvers and how to use them.","category":"page"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"If you don't have time for the details and you're just looking for a recommendation, skip to Choosing a solver.","category":"page"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"If you're interested in the interface of solvers, skip to Solver interface.","category":"page"},{"location":"reference/solvers/#Cholesky-(CHOLMOD)","page":"Solvers","title":"Cholesky (CHOLMOD)","text":"","category":"section"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"CHOLMOD is a state-of-the-art direct solver for sparse linear systems. CholeskySolver uses CHOLMOD to compute the sparse Cholesky factorization of the precision matrix, which it then leverages to draw samples and compute  posterior means. Marginal variances are computed using a user-specified variance strategy, which defaults to a sampling-based approach.","category":"page"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"CholeskySolverBlueprint","category":"page"},{"location":"reference/solvers/#GMRFs.CholeskySolverBlueprint","page":"Solvers","title":"GMRFs.CholeskySolverBlueprint","text":"CholeskySolverBlueprint(; var_strategy = RBMCStrategy(100), perm = nothing)\n\nA blueprint for a direct solver that uses a sparse Cholesky decomposition computed through CHOLMOD.\n\nKeyword arguments\n\nvar_strategy::AbstractVarianceStrategy: Strategy for computing the marginal  variances of the GMRF. Defaults to RBMCStrategy(100).\nperm::Union{Nothing,Vector{Int}}: Permutation / node reordering to use for   the Cholesky decomposition. Defaults to nothing, which means that the   solver will compute its own permutation.\n\n\n\n\n\n","category":"type"},{"location":"reference/solvers/#Pardiso","page":"Solvers","title":"Pardiso","text":"","category":"section"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"Pardiso is a state-of-the-art direct solver for sparse linear systems. Its main benefit over the CholeskySolver is its potential for better performance on large-dimensional GMRFs, as well as its highly efficient method for marginal variance computation.","category":"page"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"To use this solver, you need to set up and load Pardiso.jl. The code for our Pardiso solver will then be loaded automatically through a package extension.","category":"page"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"PardisoGMRFSolverBlueprint","category":"page"},{"location":"reference/solvers/#GMRFs.PardisoGMRFSolverBlueprint","page":"Solvers","title":"GMRFs.PardisoGMRFSolverBlueprint","text":"PardisoGMRFSolverBlueprint\n\nA blueprint for a direct solver that uses Pardiso internally.\n\nHighly efficient, but requires a Pardiso license.\n\n\n\n\n\n","category":"type"},{"location":"reference/solvers/#CG","page":"Solvers","title":"CG","text":"","category":"section"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"The Conjugate Gradient (CG) method is an iterative method for solving symmetric positive-definite linear systems. CGSolver uses CG to compute posterior means and draw samples.","category":"page"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"CGSolverBlueprint","category":"page"},{"location":"reference/solvers/#GMRFs.CGSolverBlueprint","page":"Solvers","title":"GMRFs.CGSolverBlueprint","text":"CGSolverBlueprint(; reltol, abstol, maxiter, preconditioner_strategy,\n                    var_strategy, mean_residual_guess)\n\nA blueprint for a conjugate gradient-based solver.\n\nKeyword arguments\n\nreltol::Real = sqrt(eps(Float64)): Relative tolerance of CG.\nabstol::Real = 0.0: Absolute tolerance of CG.\nmaxiter::Int = 1000: Maximum number of iterations.\npreconditioner_strategy::Function: Maps a GMRF instance to a preconditioner.\nvar_strategy::AbstractVarianceStrategy: A variance strategy.\nmean_residual_guess::Union{Nothing,AbstractVector}: An initial guess for the                                                       mean residual.\n\n\n\n\n\n","category":"type"},{"location":"reference/solvers/#Variance-strategies","page":"Solvers","title":"Variance strategies","text":"","category":"section"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"Fundamentally, computing marginal variances of GMRFs is not trivial, as it requires computing the diagonal entries of the covariance matrix (which is the inverse of the precision matrix). The Takahashi recursions (sometimes referred to as a sparse (partial) inverse method) are a highly accurate and stable method for computing these variances. TakahashiStrategy uses the Takahashi recursions to compute marginal variances. PardisoSolver also uses this algorithm internally, but with a highly optimized implementation.","category":"page"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"RBMCStrategy is a sampling-based approach to computing marginal variances. It is less accurate than the Takahashi recursions, but can be much faster for large GMRFs.","category":"page"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"TakahashiStrategy\nRBMCStrategy\nBlockRBMCStrategy","category":"page"},{"location":"reference/solvers/#GMRFs.TakahashiStrategy","page":"Solvers","title":"GMRFs.TakahashiStrategy","text":"TakahashiStrategy()\n\nTakahashi recursions [1] for computing the marginal variances of a GMRF. Highly accurate, but computationally expensive. Uses SparseInverseSubset.jl.\n\n\n\n\n\n","category":"type"},{"location":"reference/solvers/#GMRFs.RBMCStrategy","page":"Solvers","title":"GMRFs.RBMCStrategy","text":"RBMCStrategy(n_samples; rng)\n\nRao-Blackwellized Monte Carlo estimator of a GMRF's marginal variances based on [3]. Particularly useful in large-scale regimes where Takahashi recursions may be too expensive.\n\nArguments\n\nn_samples::Int: Number of samples to draw.\n\nKeyword arguments\n\nrng::Random.AbstractRNG = Random.default_rng(): Random number generator.\n\n\n\n\n\n","category":"type"},{"location":"reference/solvers/#GMRFs.BlockRBMCStrategy","page":"Solvers","title":"GMRFs.BlockRBMCStrategy","text":"BlockRBMCStrategy(n_samples; rng, enclosure_size)\n\nBlock Rao-Blackwellized Monte Carlo estimator of a GMRF's marginal variances based on [3]. Achieves faster convergence than plain RBMC by considering blocks of nodes rather than individual nodes, thus integrating more information about the precision matrix. enclosure_size specifies the size of these blocks. Larger values lead to faster convergence (in terms of the number of samples) at the cost of increased compute. Thus, one should aim for a sweet spot between sampling costs and block operation costs.\n\nArguments\n\nn_samples::Int: Number of samples to draw.\n\nKeyword arguments\n\nrng::Random.AbstractRNG = Random.default_rng(): Random number generator.\nenclosure_size::Int = 1: Size of the blocks.\n\n\n\n\n\n","category":"type"},{"location":"reference/solvers/#Choosing-a-solver","page":"Solvers","title":"Choosing a solver","text":"","category":"section"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"The default solver uses the CholeskySolver for small to medium-sized GMRFs and switches to the CGSolver for large GRMFs.  Similarly, the default variance strategy is TakahashiStrategy for small to  medium-sized GMRFs and RBMCStrategy for large GMRFs. See:","category":"page"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"DefaultSolverBlueprint","category":"page"},{"location":"reference/solvers/#GMRFs.DefaultSolverBlueprint","page":"Solvers","title":"GMRFs.DefaultSolverBlueprint","text":"DefaultSolverBlueprint()\n\nDefault solver blueprint which switches from Cholesky to CG based on the size of the GMRF.\n\n\n\n\n\n","category":"type"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"Indeed, this matches our general recommendations: Direct solvers combined with the Takahashi recursions are highly accurate and stable and should be used whenever possible. However, direct solvers become prohibitively expensive for very large-scale GMRFs, both in terms of compute and memory use. In these regimes, CG with a good preconditioner may still be a viable option.","category":"page"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"If you have access to both strong parallel computing resources and a Pardiso license, we recommend the use of the PardisoGMRFSolver. In particular, Pardiso's Takahashi recursions are highly optimized and much faster than the implementation used for our TakahashiStrategy.","category":"page"},{"location":"reference/solvers/#Solver-interface","page":"Solvers","title":"Solver interface","text":"","category":"section"},{"location":"reference/solvers/","page":"Solvers","title":"Solvers","text":"AbstractSolver\nAbstractSolverBlueprint\nAbstractVarianceStrategy\ngmrf_precision\ncompute_mean\ncompute_variance\ncompute_rand!","category":"page"},{"location":"reference/solvers/#GMRFs.AbstractSolver","page":"Solvers","title":"GMRFs.AbstractSolver","text":"AbstractSolver\n\nAn abstract type for a solver, which provides methods to compute the mean, variance, and random samples from a Gaussian Markov Random Field (GMRF).\n\n\n\n\n\n","category":"type"},{"location":"reference/solvers/#GMRFs.AbstractSolverBlueprint","page":"Solvers","title":"GMRFs.AbstractSolverBlueprint","text":"AbstractSolverBlueprint\n\nAn abstract type for a blueprint to construct a solver. A blueprint contains parameters and settings for a solver which are independent of the concrete GMRF it will be used on.\n\n\n\n\n\n","category":"type"},{"location":"reference/solvers/#GMRFs.AbstractVarianceStrategy","page":"Solvers","title":"GMRFs.AbstractVarianceStrategy","text":"AbstractVarianceStrategy\n\nAn abstract type for a strategy to compute the variance of a GMRF.\n\n\n\n\n\n","category":"type"},{"location":"reference/solvers/#GMRFs.gmrf_precision","page":"Solvers","title":"GMRFs.gmrf_precision","text":"gmrf_precision(s::AbstractSolver)\n\nReturn the precision map of the GMRF associated with a solver.\n\n\n\n\n\n","category":"function"},{"location":"reference/solvers/#GMRFs.compute_mean","page":"Solvers","title":"GMRFs.compute_mean","text":"compute_mean(s::AbstractSolver)\n\nCompute the mean of the GMRF associated with a solver.\n\n\n\n\n\n","category":"function"},{"location":"reference/solvers/#GMRFs.compute_variance","page":"Solvers","title":"GMRFs.compute_variance","text":"compute_variance(s::AbstractSolver)\n\nCompute the marginal variances of the GMRF associated with a solver.\n\n\n\n\n\n","category":"function"},{"location":"reference/solvers/#GMRFs.compute_rand!","page":"Solvers","title":"GMRFs.compute_rand!","text":"compute_rand!(s::AbstractSolver, rng::Random.AbstractRNG, x::AbstractVector)\n\nGenerate a random sample from the GMRF associated with a solver.\n\n\n\n\n\n","category":"function"},{"location":"dev-docs/discretizations/#Discretizations","page":"Discretizations","title":"Discretizations","text":"","category":"section"},{"location":"dev-docs/discretizations/#Spatial-discretization-with-FEM","page":"Discretizations","title":"Spatial discretization with FEM","text":"","category":"section"},{"location":"dev-docs/discretizations/","page":"Discretizations","title":"Discretizations","text":"GMRFs.shape_gradient_local\nGMRFs.shape_gradient_global\nGMRFs.shape_hessian_local\nGMRFs.shape_hessian_global\nGMRFs.geom_jacobian\nGMRFs.geom_hessian","category":"page"},{"location":"dev-docs/discretizations/#GMRFs.shape_gradient_local","page":"Discretizations","title":"GMRFs.shape_gradient_local","text":"shape_gradient_local(f::FEMDiscretization, shape_idx::Int, ξ)\n\nGradient of the shape function with index shape_idx with respect to the local coordinates ξ.\n\n\n\n\n\n","category":"function"},{"location":"dev-docs/discretizations/#GMRFs.shape_gradient_global","page":"Discretizations","title":"GMRFs.shape_gradient_global","text":"shape_gradient_global(f::FEMDiscretization, dof_coords, shape_idx::Int, ξ; J⁻¹ = nothing)\n\nGradient of the shape function with index shape_idx in a cell with node coordinates dof_coords, taken with respect to the global coordinates but computed in terms of the local coordinates ξ.\n\n\n\n\n\n","category":"function"},{"location":"dev-docs/discretizations/#GMRFs.shape_hessian_local","page":"Discretizations","title":"GMRFs.shape_hessian_local","text":"shape_hessian_local(f::FEMDiscretization, shape_idx::Int, ξ)\n\nHessian of the shape function with index shape_idx with respect to the local coordinates ξ.\n\n\n\n\n\n","category":"function"},{"location":"dev-docs/discretizations/#GMRFs.shape_hessian_global","page":"Discretizations","title":"GMRFs.shape_hessian_global","text":"shape_hessian_global(f::FEMDiscretization, dof_coords, shape_idx::Int, ξ; J⁻¹ = nothing, geo_hessian = nothing)\n\nHessian of the shape function with index shape_idx in a cell with node coordinates dof_coords, taken with respect to the global coordinates but computed in terms of the local coordinates ξ.\n\n\n\n\n\n","category":"function"},{"location":"dev-docs/discretizations/#GMRFs.geom_jacobian","page":"Discretizations","title":"GMRFs.geom_jacobian","text":"geom_jacobian(f::FEMDiscretization, dof_coords, ξ)\n\nJacobian of the geometry mapping at the local coordinates ξ with node coordinates dof_coords. By \"geometry mapping\", we mean the mapping from the reference element to the physical element.\n\n\n\n\n\n","category":"function"},{"location":"dev-docs/discretizations/#GMRFs.geom_hessian","page":"Discretizations","title":"GMRFs.geom_hessian","text":"geom_hessian(f::FEMDiscretization, dof_coords, ξ)\n\nHessian of the geometry mapping at the local coordinates ξ with node coordinates dof_coords. By \"geometry mapping\", we mean the mapping from the reference element to the physical element.\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#Spatial-and-spatiotemporal-discretizations","page":"Discretizations","title":"Spatial and spatiotemporal discretizations","text":"","category":"section"},{"location":"reference/discretizations/#Discretizing-SPDEs","page":"Discretizations","title":"Discretizing SPDEs","text":"","category":"section"},{"location":"reference/discretizations/","page":"Discretizations","title":"Discretizations","text":"discretize","category":"page"},{"location":"reference/discretizations/#GMRFs.discretize","page":"Discretizations","title":"GMRFs.discretize","text":"discretize(𝒟::MaternSPDE{D}, discretization::FEMDiscretization{D})::AbstractGMRF where {D}\n\nDiscretize a Matérn SPDE using a Finite Element Method (FEM) discretization. Computes the stiffness and (lumped) mass matrix, and then forms the precision matrix of the GMRF discretization.\n\n\n\n\n\ndiscretize(spde::AdvectionDiffusionSPDE, discretization::FEMDiscretization,\nts::AbstractVector{Float64}; colored_noise = false,\nstreamline_diffusion = false, h = 0.1) where {D}\n\nDiscretize an advection-diffusion SPDE using a constant spatial mesh. Streamline diffusion is an optional stabilization scheme for advection-dominated problems, which are known to be unstable. When using streamline diffusion, h may be passed to specify the mesh element size.\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#Spatial-discretization:-FEM","page":"Discretizations","title":"Spatial discretization: FEM","text":"","category":"section"},{"location":"reference/discretizations/","page":"Discretizations","title":"Discretizations","text":"FEMDiscretization\nndim\nFerrite.ndofs(::FEMDiscretization)","category":"page"},{"location":"reference/discretizations/#GMRFs.FEMDiscretization","page":"Discretizations","title":"GMRFs.FEMDiscretization","text":"FEMDiscretization(\n    grid::Ferrite.Grid,\n    interpolation::Ferrite.Interpolation,\n    quadrature_rule::Ferrite.QuadratureRule,\n    fields = ((:u, nothing),),\n    boundary_conditions = (),\n)\n\nA struct that contains all the information needed to discretize an (S)PDE using the Finite Element Method.\n\nArguments\n\ngrid::Ferrite.Grid: The grid on which the discretization is defined.\ninterpolation::Ferrite.Interpolation: The interpolation scheme, i.e. the                                         type of FEM elements.\nquadrature_rule::Ferrite.QuadratureRule: The quadrature rule.\nfields::Vector{Tuple{Symbol, Union{Nothing, Ferrite.Interpolation}}}:       The fields to be discretized. Each tuple contains the field name and       the geometric interpolation scheme. If the interpolation scheme is       nothing, interpolation is used for geometric interpolation.\nboundary_conditions::Vector{Tuple{Ferrite.BoundaryCondition, Float64}}:       The (soft) boundary conditions. Each tuple contains the boundary       condition and the noise standard deviation.\n\n\n\n\n\n","category":"type"},{"location":"reference/discretizations/#GMRFs.ndim","page":"Discretizations","title":"GMRFs.ndim","text":"ndim(f::FEMDiscretization)\n\nReturn the dimension of space in which the discretization is defined. Typically ndim(f) == 1, 2, or 3.\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#Ferrite.ndofs-Tuple{FEMDiscretization}","page":"Discretizations","title":"Ferrite.ndofs","text":"ndofs(f::FEMDiscretization)\n\nReturn the number of degrees of freedom in the discretization.\n\n\n\n\n\n","category":"method"},{"location":"reference/discretizations/","page":"Discretizations","title":"Discretizations","text":"evaluation_matrix\nnode_selection_matrix\nderivative_matrices\nsecond_derivative_matrices","category":"page"},{"location":"reference/discretizations/#GMRFs.evaluation_matrix","page":"Discretizations","title":"GMRFs.evaluation_matrix","text":"evaluation_matrix(f::FEMDiscretization, X)\n\nReturn the matrix A such that A[i, j] is the value of the j-th basis function at the i-th point in X.\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#GMRFs.node_selection_matrix","page":"Discretizations","title":"GMRFs.node_selection_matrix","text":"node_selection_matrix(f::FEMDiscretization, node_ids)\n\nReturn the matrix A such that A[i, j] = 1 if the j-th basis function is associated with the i-th node in node_ids.\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#GMRFs.derivative_matrices","page":"Discretizations","title":"GMRFs.derivative_matrices","text":"derivative_matrices(f::FEMDiscretization{D}, X; derivative_idcs = [1])\n\nReturn a vector of matrices such that mats[k][i, j] is the derivative of the j-th basis function at X[i], where the partial derivative index is given by derivative_idcs[k].\n\nExamples\n\nWe're modelling a 2D function u(x, y) and we want the derivatives with respect to y at two input points.\n\nusing Ferrite # hide\ngrid = generate_grid(Triangle, (20,20)) # hide\nip = Lagrange{2, RefTetrahedron, 1}() # hide\nqr = QuadratureRule{2, RefTetrahedron}(2) # hide\ndisc = FEMDiscretization(grid, ip, qr)\nX = [Tensors.Vec(0.11, 0.22), Tensors.Vec(-0.1, 0.4)]\n\nmats = derivative_matrices(disc, X; derivative_idcs=[2])\n\nmats contains a single matrix of size (2, ndofs(disc)) where the i-th row contains the derivative of all basis functions with respect to y at X[i].\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#GMRFs.second_derivative_matrices","page":"Discretizations","title":"GMRFs.second_derivative_matrices","text":"second_derivative_matrices(f::FEMDiscretization{D}, X; derivative_idcs = [(1,1)])\n\nReturn a vector of matrices such that mats[k][i, j] is the second derivative of the j-th basis function at X[i], where the partial derivative index is given by derivative_idcs[k]. Note that the indices refer to the Hessian, i.e. (1, 2) corresponds to ∂²/∂x∂y.\n\nExamples\n\nWe're modelling a 2D function u(x, y) and we want to evaluate the Laplacian at two input points.\n\nusing Ferrite # hide\ngrid = generate_grid(Triangle, (20,20)) # hide\nip = Lagrange{2, RefTetrahedron, 1}() # hide\nqr = QuadratureRule{2, RefTetrahedron}(2) # hide\ndisc = FEMDiscretization(grid, ip, qr)\nX = [Tensors.Vec(0.11, 0.22), Tensors.Vec(-0.1, 0.4)]\n\nA, B = derivative_matrices(disc, X; derivative_idcs=[(1, 1), (2, 2)])\nlaplacian = A + B\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#Utilities","page":"Discretizations","title":"Utilities","text":"","category":"section"},{"location":"reference/discretizations/","page":"Discretizations","title":"Discretizations","text":"assemble_mass_matrix\nassemble_diffusion_matrix\nassemble_advection_matrix\nlump_matrix\nassemble_streamline_diffusion_matrix\napply_soft_constraints!","category":"page"},{"location":"reference/discretizations/#GMRFs.assemble_mass_matrix","page":"Discretizations","title":"GMRFs.assemble_mass_matrix","text":"assemble_mass_matrix(\n    Ce::SparseMatrixCSC,\n    cellvalues::CellValues,\n    interpolation;\n    lumping = true,\n)\n\nAssemble the mass matrix Ce for the given cell values.\n\nArguments\n\nCe::SparseMatrixCSC: The mass matrix.\ncellvalues::CellValues: Ferrite cell values.\ninterpolation::Interpolation: The interpolation scheme.\nlumping::Bool=true: Whether to lump the mass matrix.\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#GMRFs.assemble_diffusion_matrix","page":"Discretizations","title":"GMRFs.assemble_diffusion_matrix","text":"assemble_diffusion_matrix(\n    Ge::SparseMatrixCSC,\n    cellvalues::CellValues;\n    diffusion_factor = I,\n)\n\nAssemble the diffusion matrix Ge for the given cell values.\n\nArguments\n\nGe::SparseMatrixCSC: The diffusion matrix.\ncellvalues::CellValues: Ferrite cell values.\ndiffusion_factor=I: The diffusion factor.\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#GMRFs.assemble_advection_matrix","page":"Discretizations","title":"GMRFs.assemble_advection_matrix","text":"assemble_advection_matrix(\n    Be::SparseMatrixCSC,\n    cellvalues::CellValues;\n    advection_velocity = 1,\n)\n\nAssemble the advection matrix Be for the given cell values.\n\nArguments\n\nBe::SparseMatrixCSC: The advection matrix.\ncellvalues::CellValues: Ferrite cell values.\nadvection_velocity=1: The advection velocity.\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#GMRFs.lump_matrix","page":"Discretizations","title":"GMRFs.lump_matrix","text":"lump_matrix(A::AbstractMatrix, ::Lagrange{D, S, 1}) where {D, S}\n\nLump a matrix by summing over the rows.\n\n\n\n\n\nlump_matrix(A::AbstractMatrix, ::Lagrange)\n\nLump a matrix through HRZ lumping. Fallback for non-linear elements. Row-summing cannot be used for non-linear elements, because it does not ensure positive definiteness.\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#GMRFs.assemble_streamline_diffusion_matrix","page":"Discretizations","title":"GMRFs.assemble_streamline_diffusion_matrix","text":"assemble_streamline_diffusion_matrix(\n    Ge::SparseMatrixCSC,\n    cellvalues::CellValues,\n    advection_velocity,\n    h,\n)\n\nAssemble the streamline diffusion matrix Ge for the given cell values.\n\nArguments\n\nGe::SparseMatrixCSC: The streamline diffusion matrix.\ncellvalues::CellValues: Ferrite cell values.\nadvection_velocity: The advection velocity.\nh: The mesh size.\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#GMRFs.apply_soft_constraints!","page":"Discretizations","title":"GMRFs.apply_soft_constraints!","text":"apply_soft_constraints!(K, f_rhs, ch, constraint_noise; Q_rhs = nothing, Q_rhs_sqrt = nothing)\n\nApply soft constraints to the Gaussian relation\n\nmathbfK mathbfu sim mathcalN(mathbff_textrhs mathbfQ_textrhs^-1)\n\nSoft means that the constraints are fulfilled up to noise of magnitude specified by constraint_noise.\n\nModifies K and f_rhs in place. If Q_rhs and Q_rhs_sqrt are provided, they are modified in place as well.\n\nArguments\n\nK::SparseMatrixCSC: Stiffness matrix.\nf_rhs::AbstractVector: Right-hand side.\nch::ConstraintHandler: Constraint handler.\nconstraint_noise::Vector{Float64}: Noise for each constraint.\nQ_rhs::Union{Nothing, SparseMatrixCSC}: Covariance matrix for the right-hand                                           side.\nQ_rhs_sqrt::Union{Nothing, SparseMatrixCSC}: Square root of the covariance                                                matrix for the right-hand side.\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#Temporal-discretization-and-state-space-models","page":"Discretizations","title":"Temporal discretization and state-space models","text":"","category":"section"},{"location":"reference/discretizations/","page":"Discretizations","title":"Discretizations","text":"JointSSMMatrices\njoint_ssm\nImplicitEulerSSM\nImplicitEulerJointSSMMatrices","category":"page"},{"location":"reference/discretizations/#GMRFs.JointSSMMatrices","page":"Discretizations","title":"GMRFs.JointSSMMatrices","text":"JointSSMMatrices\n\nAbstract type for the matrices defining the transition of a certain linear state-space model of the form\n\nG(Δt) x_k+1  xₖ  𝒩(M(Δt) xₖ Σ)\n\nFields\n\nΔt::Real: Time step.\nG::LinearMap: Transition matrix.\nM::LinearMap: Observation matrix.\nΣ⁻¹::LinearMap: Transition precision map.\nΣ⁻¹_sqrt::LinearMap: Square root of the transition precision map.\nconstraint_handler: Ferrite constraint handler.\nconstraint_noise: Constraint noise.\n\n\n\n\n\n","category":"type"},{"location":"reference/discretizations/#GMRFs.joint_ssm","page":"Discretizations","title":"GMRFs.joint_ssm","text":"joint_ssm(x₀::GMRF, ssm_matrices::Function, ts::AbstractVector)\n\nForm the joint GMRF for the linear state-space model given by\n\nG(Δtₖ) x_k+1  xₖ  𝒩(M(Δtₖ) xₖ Σ)\n\nat time points given by ts (from which the Δtₖ are computed).\n\n\n\n\n\n","category":"function"},{"location":"reference/discretizations/#GMRFs.ImplicitEulerSSM","page":"Discretizations","title":"GMRFs.ImplicitEulerSSM","text":"ImplicitEulerSSM(\n    x₀::AbstractGMRF,\n    G::Function,\n    M::Function,\n    M⁻¹::Function,\n    β::Function,\n    β⁻¹::Function,\n    spatial_noise::AbstractGMRF,\n    ts::AbstractVector,\n    constraint_handler::ConstraintHandler,\n    constraint_noise::AbstractVector,\n)\n\nState-space model for the implicit Euler discretization of a stochastic differential equation.\n\nThe state-space model is given by\n\nG(Δt) xₖ₊₁ = M(Δt) xₖ + M(Δt) β(Δt) zₛ\n\nwhere zₛ is (possibly colored) spatial noise. \n\n\n\n\n\n","category":"type"},{"location":"reference/discretizations/#GMRFs.ImplicitEulerJointSSMMatrices","page":"Discretizations","title":"GMRFs.ImplicitEulerJointSSMMatrices","text":"ImplicitEulerJointSSMMatrices(\n    ssm::ImplicitEulerSSM,\n    Δt::Real\n)\n\nConstruct the joint state-space model matrices for the implicit Euler discretization scheme.\n\nArguments\n\nssm::ImplicitEulerSSM: The implicit Euler state-space model.\nΔt::Real: The time step.\n\n\n\n\n\n","category":"type"},{"location":"reference/gn_optim/#Gauss-Newton-Optimization","page":"Gauss-Newton optimization","title":"Gauss-Newton Optimization","text":"","category":"section"},{"location":"reference/gn_optim/","page":"Gauss-Newton optimization","title":"Gauss-Newton optimization","text":"GaussNewtonOptimizer\noptimize\ntake_step","category":"page"},{"location":"reference/gn_optim/#GMRFs.GaussNewtonOptimizer","page":"Gauss-Newton optimization","title":"GMRFs.GaussNewtonOptimizer","text":"GaussNewtonOptimizer\n\nTunable Gauss-Newton optimization routine to find the maximum a posteriori (MAP) estimate under nonlinear observations and a GMRF prior. TODO: Explain parameters.\n\n\n\n\n\n","category":"type"},{"location":"reference/gn_optim/#GMRFs.optimize","page":"Gauss-Newton optimization","title":"GMRFs.optimize","text":"optimize(optim::GaussNewtonOptimizer)\n\nIterate until the stopping criterion is fulfilled.\n\n\n\n\n\n","category":"function"},{"location":"reference/gn_optim/#GMRFs.take_step","page":"Gauss-Newton optimization","title":"GMRFs.take_step","text":"take_step(optim::GaussNewtonOptimizer)\n\nTake a Gauss-Newton step in the optimization process.\n\n\n\n\n\n","category":"function"},{"location":"reference/gn_optim/#Solvers","page":"Gauss-Newton optimization","title":"Solvers","text":"","category":"section"},{"location":"reference/gn_optim/","page":"Gauss-Newton optimization","title":"Gauss-Newton optimization","text":"GNLinearSolverBlueprint\nGNCholeskySolverBlueprint\nGNCGSolverBlueprint","category":"page"},{"location":"reference/gn_optim/#GMRFs.GNLinearSolverBlueprint","page":"Gauss-Newton optimization","title":"GMRFs.GNLinearSolverBlueprint","text":"GNLinearSolverBlueprint\n\nAbstract type for the specification of a solver for the linear systems arising in Gauss-Newton optimization.\n\n\n\n\n\n","category":"type"},{"location":"reference/gn_optim/#GMRFs.GNCholeskySolverBlueprint","page":"Gauss-Newton optimization","title":"GMRFs.GNCholeskySolverBlueprint","text":"GNCholeskySolverBlueprint(perm)\n\nSpecification of a linear solver for Gauss-Newton systems based on the Cholesky decomposition. perm is a node reordering (permutation) to minimize fill-in. If such a reordering is available from previous computations, it can be reused here to avoid unnecessary computational overhead. If perm is not passed, it will be computed during the Cholesky decomposition.\n\n\n\n\n\n","category":"type"},{"location":"reference/gn_optim/#GMRFs.GNCGSolverBlueprint","page":"Gauss-Newton optimization","title":"GMRFs.GNCGSolverBlueprint","text":"GNCGSolverBlueprint(; maxiter, reltol, abstol, preconditioner_fn, verbose)\n\nSpecification of a linear solver for Gauss-Newton systems based on the conjugate gradient (CG) method.\n\n\n\n\n\n","category":"type"},{"location":"reference/gn_optim/#Line-search-strategies","page":"Gauss-Newton optimization","title":"Line search strategies","text":"","category":"section"},{"location":"reference/gn_optim/","page":"Gauss-Newton optimization","title":"Gauss-Newton optimization","text":"AbstractLineSearch\nBacktrackingLineSearch\nNoLineSearch","category":"page"},{"location":"reference/gn_optim/#GMRFs.AbstractLineSearch","page":"Gauss-Newton optimization","title":"GMRFs.AbstractLineSearch","text":"AbstractLineSearch\n\nAbstract type for the specification of a line search scheme for optimization.\n\n\n\n\n\n","category":"type"},{"location":"reference/gn_optim/#GMRFs.BacktrackingLineSearch","page":"Gauss-Newton optimization","title":"GMRFs.BacktrackingLineSearch","text":"BacktrackingLineSearch\n\nSpecification of a line search based on backtracking via the Armijo condition. TODO: Description of parameters\n\n\n\n\n\n","category":"type"},{"location":"reference/gn_optim/#GMRFs.NoLineSearch","page":"Gauss-Newton optimization","title":"GMRFs.NoLineSearch","text":"NoLineSearch\n\nA type that communicates that no line search will be used, i.e. the initial step proposed by the optimization algorithm is the step that will be taken.\n\n\n\n\n\n","category":"type"},{"location":"reference/gn_optim/#Stopping-criteria","page":"Gauss-Newton optimization","title":"Stopping criteria","text":"","category":"section"},{"location":"reference/gn_optim/","page":"Gauss-Newton optimization","title":"Gauss-Newton optimization","text":"AbstractStoppingCriterion\nNewtonDecrementCriterion\nStepNumberCriterion\nOrCriterion","category":"page"},{"location":"reference/gn_optim/#GMRFs.AbstractStoppingCriterion","page":"Gauss-Newton optimization","title":"GMRFs.AbstractStoppingCriterion","text":"AbstractStoppingCriterion\n\nAbstract type for the specification of a criterion that tells an optimization algorithm when to stop iterating.\n\n\n\n\n\n","category":"type"},{"location":"reference/gn_optim/#GMRFs.NewtonDecrementCriterion","page":"Gauss-Newton optimization","title":"GMRFs.NewtonDecrementCriterion","text":"NewtonDecrementCriterion(threshold)\n\nStops the optimization procedure when ∇f(xₖ) ∇²f(xₖ)⁻¹ ∇f(xₖ) < threshold.\n\n\n\n\n\n","category":"type"},{"location":"reference/gn_optim/#GMRFs.StepNumberCriterion","page":"Gauss-Newton optimization","title":"GMRFs.StepNumberCriterion","text":"StepNumberCriterion(max_steps)\n\nStops the optimization procedure when a maximum number of iterations / steps is reached.\n\n\n\n\n\n","category":"type"},{"location":"reference/gn_optim/#GMRFs.OrCriterion","page":"Gauss-Newton optimization","title":"GMRFs.OrCriterion","text":"OrCriterion(criteria)\n\nStops the optimization procedure when any of the criteria in criteria are fulfilled.\n\n\n\n\n\n","category":"type"},{"location":"reference/gmrfs/#GMRFs","page":"GMRFs","title":"GMRFs","text":"","category":"section"},{"location":"reference/gmrfs/","page":"GMRFs","title":"GMRFs","text":"AbstractGMRF\nGMRF\nprecision_map","category":"page"},{"location":"reference/gmrfs/#GMRFs.AbstractGMRF","page":"GMRFs","title":"GMRFs.AbstractGMRF","text":"AbstractGMRF\n\nA Gaussian Markov Random Field  (GMRF) is a special case of a multivariate normal distribution where the precision matrix is sparse. The zero entries in the precision correspond to conditional independencies.\n\n\n\n\n\n","category":"type"},{"location":"reference/gmrfs/#GMRFs.GMRF","page":"GMRFs","title":"GMRFs.GMRF","text":"GMRF{T}(mean, precision, solver_ref)\n\nA Gaussian Markov Random Field with mean mean and precision matrix precision. Carries a reference to a solver for the GMRF quantities.\n\n\n\n\n\n","category":"type"},{"location":"reference/gmrfs/#GMRFs.precision_map","page":"GMRFs","title":"GMRFs.precision_map","text":"precision_map(::AbstractGMRF)\n\nReturn the precision (inverse covariance) map of the GMRF.\n\n\n\n\n\n","category":"function"},{"location":"reference/gmrfs/#Arithmetic","page":"GMRFs","title":"Arithmetic","text":"","category":"section"},{"location":"reference/gmrfs/","page":"GMRFs","title":"GMRFs","text":"condition_on_observations\nLinearConditionalGMRF\njoint_gmrf","category":"page"},{"location":"reference/gmrfs/#GMRFs.condition_on_observations","page":"GMRFs","title":"GMRFs.condition_on_observations","text":"\"     conditiononobservations(         x::AbstractGMRF,         A::Union{AbstractMatrix,LinearMap},         Qϵ::Union{AbstractMatrix,LinearMap,Real},         y::AbstractVector=spzeros(size(A)[1]),         b::AbstractVector=spzeros(size(A)[1]);         solverblueprint::AbstractSolverBlueprint=CholeskySolverBlueprint()     )\n\nCondition a GMRF x on observations y = A * x + b + ϵ where ϵ ~ N(0, Q_ϵ⁻¹).\n\nArguments\n\nx::AbstractGMRF: The GMRF to condition on.\nA::Union{AbstractMatrix,LinearMap}: The matrix A.\nQ_ϵ::Union{AbstractMatrix,LinearMap, Real}: The precision matrix of the        noise term ϵ. In case a real number is provided, it is interpreted        as a scalar multiple of the identity matrix.\ny::AbstractVector=spzeros(size(A)[1]): The observations y; optional.\nb::AbstractVector=spzeros(size(A)[1]): Offset vector b; optional.\n\nKeyword arguments\n\nsolver_blueprint::AbstractSolverBlueprint=CholeskySolverBlueprint():        The solver blueprint; optional.\n\nReturns\n\nA LinearConditionalGMRF object representing the conditional GMRF x | (y = A * x + b + ϵ).\n\n\n\n\n\n","category":"function"},{"location":"reference/gmrfs/#GMRFs.LinearConditionalGMRF","page":"GMRFs","title":"GMRFs.LinearConditionalGMRF","text":"LinearConditionalGMRF{G}(\n    prior::G,\n    A::Union{AbstractMatrix,LinearMap},\n    Q_ϵ::Union{AbstractMatrix,LinearMap},\n    y::AbstractVector,\n    b::AbstractVector=spzeros(size(A, 1)),\n    solver_blueprint::AbstractSolverBlueprint=DefaultSolverBlueprint(),\n) where {G<:AbstractGMRF}\n\nA GMRF conditioned on observations y = A * x + b + ϵ where ϵ ~ N(0, Q_ϵ).\n\nArguments\n\nprior::G: The prior GMRF.\nA::Union{AbstractMatrix,LinearMap}: The matrix A.\nQ_ϵ::Union{AbstractMatrix,LinearMap}: The precision matrix of the                                         noise term ϵ.\ny::AbstractVector=spzeros(size(A, 1)): The observations y.\nb::AbstractVector=spzeros(size(A, 1)): The offset vector b.\nsolver_blueprint::AbstractSolverBlueprint=DefaultSolverBlueprint():       The solver blueprint.\n\n\n\n\n\n","category":"type"},{"location":"reference/gmrfs/#GMRFs.joint_gmrf","page":"GMRFs","title":"GMRFs.joint_gmrf","text":"\"     jointgmrf(         x1::AbstractGMRF,         A::AbstractMatrix,         Qϵ::AbstractMatrix,         b::AbstractVector=spzeros(size(A)[1])     )\n\nReturn the joint GMRF of x1 and x2 = A * x1 + b + ϵ where ϵ ~ N(0, Q_ϵ⁻¹).\n\nArguments\n\nx1::AbstractGMRF: The first GMRF.\nA::AbstractMatrix: The matrix A.\nQ_ϵ::AbstractMatrix: The precision matrix of the noise term ϵ.\nb::AbstractVector=spzeros(size(A)[1]): Offset vector b; optional.\n\nReturns\n\nA GMRF object representing the joint GMRF of x1 and x2 = A * x1 + b + ϵ.\n\n\n\n\n\n","category":"function"},{"location":"reference/gmrfs/#Spatiotemporal-setting","page":"GMRFs","title":"Spatiotemporal setting","text":"","category":"section"},{"location":"reference/gmrfs/#Types","page":"GMRFs","title":"Types","text":"","category":"section"},{"location":"reference/gmrfs/","page":"GMRFs","title":"GMRFs","text":"AbstractSpatiotemporalGMRF\nConstantMeshSTGMRF\nImplicitEulerConstantMeshSTGMRF\nConcreteConstantMeshSTGMRF","category":"page"},{"location":"reference/gmrfs/#GMRFs.AbstractSpatiotemporalGMRF","page":"GMRFs","title":"GMRFs.AbstractSpatiotemporalGMRF","text":"AbstractSpatiotemporalGMRF\n\nA spatiotemporal GMRF is a GMRF that explicitly encodes the spatial and temporal structure of the underlying random field. All time points are modelled in one joint GMRF. It provides utilities to get statistics, draw samples and get the spatial discretization at a given time.\n\n\n\n\n\n","category":"type"},{"location":"reference/gmrfs/#GMRFs.ConstantMeshSTGMRF","page":"GMRFs","title":"GMRFs.ConstantMeshSTGMRF","text":"ConstantMeshSTGMRF\n\nA spatiotemporal GMRF with constant spatial discretization.\n\n\n\n\n\n","category":"type"},{"location":"reference/gmrfs/#GMRFs.ImplicitEulerConstantMeshSTGMRF","page":"GMRFs","title":"GMRFs.ImplicitEulerConstantMeshSTGMRF","text":"ImplicitEulerConstantMeshSTGMRF\n\nA spatiotemporal GMRF with constant spatial discretization and an implicit Euler discretization of the temporal dynamics.\n\n\n\n\n\n","category":"type"},{"location":"reference/gmrfs/#GMRFs.ConcreteConstantMeshSTGMRF","page":"GMRFs","title":"GMRFs.ConcreteConstantMeshSTGMRF","text":"ConcreteConstantMeshSTGMRF\n\nA concrete implementation of a spatiotemporal GMRF with constant spatial discretization.\n\n\n\n\n\n","category":"type"},{"location":"reference/gmrfs/#Quantities","page":"GMRFs","title":"Quantities","text":"","category":"section"},{"location":"reference/gmrfs/","page":"GMRFs","title":"GMRFs","text":"N_t\ntime_means\ntime_vars\ntime_stds\ntime_rands\ndiscretization_at_time","category":"page"},{"location":"reference/gmrfs/#GMRFs.N_t","page":"GMRFs","title":"GMRFs.N_t","text":"N_t(::AbstractSpatiotemporalGMRF)\n\nReturn the number of time points in the spatiotemporal GMRF.\n\n\n\n\n\n","category":"function"},{"location":"reference/gmrfs/#GMRFs.time_means","page":"GMRFs","title":"GMRFs.time_means","text":"time_means(::AbstractSpatiotemporalGMRF)\n\nReturn the means of the spatiotemporal GMRF at each time point.\n\nReturns\n\nA vector of means of length Nₜ, one for each time point.\n\n\n\n\n\n","category":"function"},{"location":"reference/gmrfs/#GMRFs.time_vars","page":"GMRFs","title":"GMRFs.time_vars","text":"time_vars(::AbstractSpatiotemporalGMRF)\n\nReturn the marginal variances of the spatiotemporal GMRF at each time point.\n\nReturns\n\nA vector of marginal variances of length Nₜ, one for each time point.\n\n\n\n\n\n","category":"function"},{"location":"reference/gmrfs/#GMRFs.time_stds","page":"GMRFs","title":"GMRFs.time_stds","text":"time_stds(::AbstractSpatiotemporalGMRF)\n\nReturn the marginal standard deviations of the spatiotemporal GMRF at each time point.\n\nReturns\n\nA vector of marginal standard deviations of length Nₜ, one for each time point.\n\n\n\n\n\n","category":"function"},{"location":"reference/gmrfs/#GMRFs.time_rands","page":"GMRFs","title":"GMRFs.time_rands","text":"time_rands(::AbstractSpatiotemporalGMRF, rng::AbstractRNG)\n\nDraw samples from the spatiotemporal GMRF at each time point.\n\nReturns\n\nA vector of sample values of length Nₜ, one sample value vector for each time point.\n\n\n\n\n\n","category":"function"},{"location":"reference/gmrfs/#GMRFs.discretization_at_time","page":"GMRFs","title":"GMRFs.discretization_at_time","text":"discretization_at_time(::AbstractSpatiotemporalGMRF, t::Int)\n\nReturn the spatial discretization at time t.\n\n\n\n\n\n","category":"function"},{"location":"reference/gmrfs/#Utilities","page":"GMRFs","title":"Utilities","text":"","category":"section"},{"location":"reference/gmrfs/","page":"GMRFs","title":"GMRFs","text":"spatial_to_spatiotemporal\nkronecker_product_spatiotemporal_model","category":"page"},{"location":"reference/gmrfs/#GMRFs.spatial_to_spatiotemporal","page":"GMRFs","title":"GMRFs.spatial_to_spatiotemporal","text":"spatial_to_spatiotemporal(\n    spatial_matrix::AbstractMatrix,\n    t_idx::Int,\n    N_t::Int,\n)\n\nMake a spatial matrix applicable to a spatiotemporal system at time index t_idx. Results in a matrix that selects the spatial information exactly at time t_idx.\n\nArguments\n\nspatial_matrix::AbstractMatrix: The spatial matrix.\nt_idx::Integer: The time index.\nN_t::Integer: The number of time points.\n\n\n\n\n\n","category":"function"},{"location":"reference/gmrfs/#GMRFs.kronecker_product_spatiotemporal_model","page":"GMRFs","title":"GMRFs.kronecker_product_spatiotemporal_model","text":"kronecker_product_spatiotemporal_model(\n    Q_t::AbstractMatrix,\n    Q_s::AbstractMatrix,\n    spatial_disc::FEMDiscretization;\n    solver_blueprint = DefaultSolverBlueprint(),\n)\n\nCreate a spatiotemporal GMRF through a Kronecker product of the temporal and spatial precision matrices.\n\nArguments\n\nQ_t::AbstractMatrix: The temporal precision matrix.\nQ_s::AbstractMatrix: The spatial precision matrix.\nspatial_disc::FEMDiscretization: The spatial discretization.\n\nKeyword arguments\n\nsolver_blueprint::AbstractSolverBlueprint=DefaultSolverBlueprint():       The solver blueprint.\n\n\n\n\n\n","category":"function"},{"location":"dev-docs/#Developer-documentation-overview","page":"Overview","title":"Developer documentation overview","text":"","category":"section"},{"location":"dev-docs/","page":"Overview","title":"Overview","text":"Pages = [\n    \"spdes.md\",\n    \"discretizations.md\",\n    \"solvers.md\"\n]","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"EditURL = \"../literate-tutorials/spatial_modelling_spdes.jl\"","category":"page"},{"location":"tutorials/spatial_modelling_spdes/#Spatial-Modelling-with-SPDEs","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"","category":"section"},{"location":"tutorials/spatial_modelling_spdes/#Data-preprocessing","page":"Spatial Modelling with SPDEs","title":"Data preprocessing","text":"","category":"section"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"In the following, we are going to work with the meuse dataset. This dataset contains measurements of zinc concentrations in the soil near the Meuse river.","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"We begin by downloading the dataset.","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"meuse_path = joinpath(@__DIR__, \"meuse.csv\")\nmeuse_URL = \"https://gist.githubusercontent.com/essicolo/91a2666f7c5972a91bca763daecdc5ff/raw/056bda04114d55b793469b2ab0097ec01a6d66c6/meuse.csv\"\ndownload(meuse_URL, meuse_path)","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"We load the CSV file into a DataFrame and inspect the first few rows.","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"using CSV, DataFrames\ndf = DataFrame(CSV.File(meuse_path))\ndf[1:5, [:x, :y, :zinc]]","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"Let us visualize the data. We plot the zinc concentrations as a function of the x and y coordinates.","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"using Plots\nx = convert(Vector{Float64}, df[:, :x])\ny = convert(Vector{Float64}, df[:, :y])\nzinc = df[:, :zinc]\nscatter(x, y, zcolor = zinc)","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"Finally, in classic machine learning fashion, we split the data into a training and a test set. We use about 85% of the data for training and the remaining 15% for testing.","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"using Random\ntrain_idcs = randsubseq(1:size(df, 1), 0.85)\ntest_idcs = [i for i = 1:size(df, 1) if isempty(searchsorted(train_idcs, i))]\nX = [x y]\nX_train = X[train_idcs, :]\nX_test = X[test_idcs, :]\ny_train = zinc[train_idcs]\ny_test = zinc[test_idcs]\nsize(X_train, 1), size(X_test, 1)","category":"page"},{"location":"tutorials/spatial_modelling_spdes/#Spatial-Modelling","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling","text":"","category":"section"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"Matern Gaussian processes (GPs) are a powerful model class commonly used in geostatistics for such data. Unfortunately, without using any further tricks, GPs have a cubic runtime complexity. As the size of the dataset grows, this quickly becomes prohibitively expensive. In the tutorial on Autoregressive models, we learned that GMRFs enable highly efficient Gaussian inference through sparse precision matrices. Can we combine the modelling power of GPs with the efficiency of GMRFs?","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"Yes, we can: [1] told us how. It turns out that Matern processes may equivalently be interpreted as solutions of certain stochastic partial differential equations (SPDEs). If we discretize this SPDE appropriately – for example using the finite element method (FEM) – we get a discrete GMRF approximation of a Matern process. The approximation quality improves as the resolution of the FEM mesh increases. If this all sounds overly complicated to you, fear not! GMRFs.jl takes care of the technical details for you, so you can focus on the modelling.","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"We start by generating a FEM mesh for our data. Internally, GMRFs.jl computes a convex hull around the scattered data and then extends it slightly to counteract effects from the boundary condition of the SPDE.","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"(Image: This image depicts the mesh generated for the scattered data.)","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"The final output is a Ferrite.jl grid. We can also save the generated mesh, e.g. to visualize it via Gmsh.","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"using GMRFs\npoints = zip(x, y)\ngrid = generate_mesh(points, 600.0, 100.0, save_path = \"meuse.msh\")","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"We can now create a FEM discretization, which consists of the grid, a choice of basis functions, and a quadrature rule.","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"using Ferrite\nip = Lagrange{RefTriangle,1}()\nqr = QuadratureRule{RefTriangle}(2)\ndisc = FEMDiscretization(grid, ip, qr)","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"We now create a Matern SPDE and discretize it. While we could specify the Matern SPDE in terms of its direct parameters κ and ν, we here choose to specify it through the more easily interpretable parameters range and smoothness.","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"spde = MaternSPDE{2}(range = 400.0, smoothness = 1)\nu_matern = discretize(spde, disc)","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"We can then condition the resulting Matern GMRF on the training data, where we assume an inverse noise variance of 10 (i.e. a variance of 0.1).","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"Λ_obs = 10.0\nA_train =\n    evaluation_matrix(disc, [Tensors.Vec(X_train[i, :]...) for i = 1:size(X_train, 1)])\nA_test = evaluation_matrix(disc, [Tensors.Vec(X_test[i, :]...) for i = 1:size(X_test, 1)])\nu_cond = condition_on_observations(u_matern, A_train, Λ_obs, y_train)","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"We can evaluate the RMSE of the posterior mean on the test data:","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"rmse = (a, b) -> sqrt(mean((a .- b) .^ 2))\nrmse(A_train * mean(u_cond), y_train), rmse(A_test * mean(u_cond), y_test)","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"We can also visualize the posterior mean and standard deviation. To this end, we write the corresponding vectors to a VTK file together with the grid data, which can then be visualized in e.g. Paraview.","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"VTKGridFile(\"meuse_mean\", disc.dof_handler) do vtk\n    write_solution(vtk, disc.dof_handler, mean(u_cond))\nend\nusing Distributions\nVTKGridFile(\"meuse_std\", disc.dof_handler) do vtk\n    write_solution(vtk, disc.dof_handler, std(u_cond))\nend","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"In the end, our posterior mean looks like this: (Image: Mean)","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"And the posterior standard deviation looks like this: (Image: Std)","category":"page"},{"location":"tutorials/spatial_modelling_spdes/#Final-note","page":"Spatial Modelling with SPDEs","title":"Final note","text":"","category":"section"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"We have seen how to combine the modelling power of GPs with the efficiency of GMRFs. This is a powerful combination that allows us to model spatial data efficiently and accurately. Note that these models are still sensitive to the choice of hyperparameters, i.e. the range and smoothness of the Matern process. So it's quite likely that you may find better hyperparameters than the ones used in this tutorial.","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"","category":"page"},{"location":"tutorials/spatial_modelling_spdes/","page":"Spatial Modelling with SPDEs","title":"Spatial Modelling with SPDEs","text":"This page was generated using Literate.jl.","category":"page"},{"location":"dev-docs/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"dev-docs/solvers/","page":"Solvers","title":"Solvers","text":"GMRFs.construct_solver","category":"page"},{"location":"dev-docs/solvers/#GMRFs.construct_solver","page":"Solvers","title":"GMRFs.construct_solver","text":"construct_solver(blueprint::AbstractSolverBlueprint, gmrf::AbstractGMRF)\n\nConstruct a solver for a GMRF using a blueprint. May be used to provide specialized solvers for specific GMRF types.\n\n\n\n\n\n","category":"function"},{"location":"reference/meshes/#Meshes","page":"Meshes","title":"Meshes","text":"","category":"section"},{"location":"reference/meshes/","page":"Meshes","title":"Meshes","text":"Finite element method discretizations of SPDEs require a mesh. GMRFs provides some utility functions to create meshes for common use cases.","category":"page"},{"location":"reference/meshes/","page":"Meshes","title":"Meshes","text":"For a hands-on example meshing a 2D point cloud, check out the tutorial Spatial Modelling with SPDEs.","category":"page"},{"location":"reference/meshes/","page":"Meshes","title":"Meshes","text":"generate_mesh\ncreate_inflated_rectangle","category":"page"},{"location":"reference/meshes/#GMRFs.generate_mesh","page":"Meshes","title":"GMRFs.generate_mesh","text":"generate_mesh(mp::GeometryBasics.MultiPoint, buffer_width::Real,\n              interior_mesh_size::Real;\n              exterior_mesh_size::Real = 2 * interior_mesh_size,\n              element_order::Int = 1, save_path=nothing)\n\nGenerate a mesh for a spatial point cloud, with a buffer to counteract boundary effects from the SPDE discretization.\n\nInput\n\nmp – MultiPoint object\nbuffer_width – Width of the buffer around the convex hull\ninterior_mesh_size – Mesh size inside the convex hull\nexterior_mesh_size – Mesh size outside the convex hull\nelement_order – Order of the element basis functions\nsave_path – Optional path to save the mesh\n\nOutput\n\nA Ferrite.Grid object\n\nAlgorithm\n\nCreate the convex hull of the point cloud via LibGEOS\nCreate the buffer around the convex hull\nCreate a mesh for the buffered polygon using Gmsh\nTransfer the Gmsh information to Ferrite\n\n\n\n\n\ngenerate_mesh(points, buffer_width::Real, interior_mesh_size::Real;\n              exterior_mesh_size::Real=2 * interior_mesh_size,\n              element_order::Int=1, save_path=nothing)\n\nGenerate a mesh from a list of points using Gmsh.\n\nInput\n\npoints – List of points\nbuffer_width – Width of the buffer around the convex hull\ninterior_mesh_size – Mesh size inside the convex hull\nexterior_mesh_size – Mesh size outside the convex hull\nelement_order – Order of the elements\nsave_path – Path to save the mesh\n\nOutput\n\nA Ferrite.Grid object\n\n\n\n\n\n","category":"function"},{"location":"reference/meshes/#GMRFs.create_inflated_rectangle","page":"Meshes","title":"GMRFs.create_inflated_rectangle","text":"create_inflated_rectangle(x0, y0, dx, dy, boundary_width, interior_mesh_size,\nexterior_mesh_size = 2 * interior_mesh_size; element_order = 1)\n\nCreate a triangular FEM discretization of a rectangle with an inflated boundary. Useful for FEM discretizations of SPDEs, where the domain is often artificially inflated to avoid undesirable boundary effects. Mesh has physical groups \"Domain\", \"Interior\", \"Interior boundary\" and possibly \"Exterior boundary\".\n\nArguments\n\nx0::Real: x-coordinate of the bottom-left corner of the rectangle\ny0::Real: y-coordinate of the bottom-left corner of the rectangle\ndx::Real: Width of the rectangle\ndy::Real: Height of the rectangle\nboundary_width::Real: Width of the inflated boundary. If 0.0, mesh will not                         be inflated at all.\ninterior_mesh_size::Real: Mesh size in the interior of the rectangle\nexterior_mesh_size::Real: Mesh size in the exterior of the rectangle\nelement_order::Int: Order of the FEM elements\n\nReturns\n\ngrid::Ferrite.Grid: the FEM discretization of the rectangle\nboundary_tags::Vector{Int}: the indices of the boundary nodes\n\n\n\n\n\n","category":"function"},{"location":"bibliography/#Bibliography","page":"Bibliography","title":"Bibliography","text":"","category":"section"},{"location":"bibliography/","page":"Bibliography","title":"Bibliography","text":"F. Lindgren, H. Rue and J. Lindström. An Explicit Link between Gaussian Fields and Gaussian Markov Random Fields: The Stochastic Partial Differential Equation Approach. Journal of the Royal Statistical Society: Series B (Statistical Methodology) 73, 423–498 (2011).\n\n\n\nL. Clarotto, D. Allard, T. Romary and N. Desassis. The SPDE Approach for Spatio-Temporal Datasets with Advection and Diffusion. Spatial Statistics 62, 100847 (2024).\n\n\n\nP. Sidén, F. Lindgren, D. Bolin and M. Villani. Efficient Covariance Approximations for Large Sparse Precision Matrices. Journal of Computational and Graphical Statistics 27, 898–909 (2018).\n\n\n\n","category":"page"},{"location":"#GMRFs.jl","page":"Home","title":"GMRFs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gaussian Markov Random Fields in Julia.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gaussian Markov Random Fields (GMRFs) are Gaussian distributions with sparse precision (inverse covariance) matrices. GMRFs.jl provides utilities for working with GMRFs in Julia. The goal is to enable flexible and efficient Bayesian inference from GMRFs, powered by sparse linear algebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In particular, we support the creation of GMRFs through finite element method discretizations of stochastic partial differential equations (SPDEs). This unlocks efficient GMRF-based approximations to commonly used Gaussian process priors. Furthermore, the expressive power of SPDEs allows for flexible, problem-tailored priors.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To get started with GMRFs.jl, consider going through the Tutorials.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GMRFs.jl can be installed via its GitHub repo from the Pkg REPL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/timweiland/GMRFs.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Afterwards, you may load the package using","category":"page"},{"location":"","page":"Home","title":"Home","text":"using GMRFs","category":"page"},{"location":"","page":"Home","title":"Home","text":"You're good to go!","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Info\nWhile a fair amount of time was spent on this documentation, it is far from perfect.  If you spot parts of the documentation that you find confusing or that are incomplete, please open an issue or a pull request. Your help is much appreciated!","category":"page"},{"location":"","page":"Home","title":"Home","text":"tip: Tip\nMissing a feature? Let us know! If you're interested in contributing, that's even better! Check our contribution guidelines for assistance.","category":"page"}]
}
